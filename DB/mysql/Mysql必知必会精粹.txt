内联结，自联结，自然联结，外部联结
视图、游标、存储过程、触发器、日志

HAVING非常类似于WHERE。事实上，目前为止所
学过的所有类型的WHERE子句都可以用HAVING来替代。唯一的差别是
WHERE过滤行，而HAVING过滤分组；

逐渐增加子查询来建立查询 用子查询测试和调试查询很有
技巧性，特别是在这些语句的复杂性不断增加的情况下更是如
此。用子查询建立（和测试）查询的最可靠的方法是逐渐进行，
这与MySQL处理它们的方法非常相同。首先，建立和测试最
内层的查询。然后，用硬编码数据建立和测试外层查询，并且
仅在确认它正常后才嵌入子查询。这时，再次测试它。对于要
增加的每个查询，重复这些步骤。这样做仅给构造查询增加了
一点点时间，但节省了以后（找出查询为什么不正常）的大量
时间，并且极大地提高了查询一开始就正常工作的可能性。

在联结两个表时，你实际上做的是将第一个表中的每一行与第二个表中的每一行配对;
WHERE子句作为过滤条件，它只包含那些匹配给定条件（这里是联结条件）的行。没有
WHERE子句，第一个表中的每个行将与第二个表中的每个行配对，而不管
它们逻辑上是否可以配在一起；

等值联结（equijoin），它基于两个表之间的
相等测试。这种联结也称为内部联结;
联结条件用特定的ON子句而不是WHERE子句给出;
ANSI SQL规范首选INNER JOIN语法;
select vend_name, prod_name, prod_price 
from vendors inner join products
on vendors.vend_id = products.vend_id;

外部联结包含了那些在相关表中没有关联行的行
select customers.cust_id, orders.order_num 
from customers left outer join orders 
on customers.cust_id = orders.cust_id;

select customers.cust_id, orders.order_num 
from customers right outer join orders 
on customers.cust_id = orders.cust_id;
在使用OUTER JOIN语法时，必须使用RIGHT或LEFT关键字
指定包括其所有行的表（RIGHT指出的是OUTER JOIN右边的表，而LEFT
指出的是OUTER JOIN左边的表）。

全文本搜索 
create table t(
    note_text  int  not NULL,
    FULLTEXT(note_text)
)ENGINE=MyISM;
#进行了索引？
为了进行全文本搜索，
MySQL根据子句FULLTEXT(note_text)的指示对它进行索引

如何删除外键约束的行？

更快的删除 如果想从表中删除所有行，不要使用DELETE。
可使用TRUNCATE TABLE语句，它完成相同的工作，但速度更
快（TRUNCATE实际是删除原来的表并重新创建一个表，而不
是逐行删除表中的数据）

每个表只允许一个AUTO_INCREMENT列，而且它必须被索引（如，通
过使它成为主键）

引擎类型可以混用；外键（用于强制实施引用完整性，如第1章所述）不能跨引擎，即使用一
个引擎的表不能引用具有使用不同引擎的表的外键；

复杂的表结构更改一般需要手动删除过程，它涉及以下步骤：
 用新的列布局创建一个新表；
 使用INSERT SELECT语句（关于这条语句的详细介绍，请参阅第
19章）从旧表复制数据到新表。如果有必要，可使用转换函数和
计算字段；
 检验包含所需数据的新表；
 重命名旧表（如果确定，可以删除它）；
 用旧表原来的名字重命名新表；
 根据需要，重新创建触发器、存储过程、索引和外键

添加外键约束 
alter table products
add constraint fk_products_vendors
foreign key (vend_id) references vendors (vend_id);

delimiter //
delimiter ;
默认的MySQL语句分隔符为;（正如你已经在迄今为止所使用
的MySQL语句中所看到的那样）。mysql命令行实用程序也使
用;作为语句分隔符。如果命令行实用程序要解释存储过程自
身内的;字符，则它们最终不会成为存储过程的成分，这会使
存储过程中的SQL出现句法错误。
解决办法是临时更改命令行实用程序的语句分隔符，

不像多数DBMS，MySQL游标只能用于存储过程（和函数）。

只有表才支持触发器，视图不支持（临时表也不
支持）

DROP TRIGGER <trigname>;
触发器不能更新或覆盖。为了修改一个触发器，必须先删除它，
然后再重新创建。

所用字符集
show variables like 'character%';
show variables like 'collation%';

