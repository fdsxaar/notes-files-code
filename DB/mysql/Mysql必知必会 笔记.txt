msyql必知必会

第三章

source /js/path/xx.sql;  执行全路径下的脚本
CREATE DATABASE <name>; 创建数据库
USE <name>; 使用数据库

SHOW TABLES; 显示表

show columns from customers; 显示表分列信息
describe customers; 同上

SHOW STATUS，用于显示广泛的服务器状态信息
SHOW CREATE DATABASE和SHOW CREATE TABLE，分别用来显示创建特定数据库或表的MySQL语句；
SHOW GRANTS，用来显示授予用户（所有用户或特定用户）的安全权限；
SHOW ERRORS和SHOW WARNINGS，用来显示服务器错误或警告消息。


第4 章 检 索 数 据

SELECT prod_name FROM products; 
SELECT prod_id, prod_name, prod_price FROM products;
SELECT * FROM products;

select distinct vend_id from products;  distinct 关键字

DISTINCT关键字应用于所有列
SELECT DISTINCT vend_id, prod_price，

select prod_price from products limit 5; 返回前几行
select prod_price from products limit 5,5; 返回5行，从第六行开始（mysql中第一行是0行
select prod_price from products limit 5 offset 5; 同上

select products.prod_name from products;完全限定的表名
select products.prod_name from crashcourse.products;

第5章 排序检索数据 

select prod_name from products order by prod_name; 排序输出 
select prod_id, prod_name, prod_price from products order by prod_name, prod_price; 按多列排序

默认升序排列ASC（ASCENDING）， 降序DESC；DESC关键字只应用到直接位于其前面的列名；
在给出ORDER BY子句时，应该保证它位于FROM子句之后。如果使用LIMIT，它必须位于ORDER BY之后。使用子句的次序不对将产生错误消息；
在字典（dictionary）排序顺序中，A被视为与a相同，这是MySQL（和大多数数据库管理系统）的默认行为；
select prod_id, prod_price, prod_name from products order by prod_price limit 1; 

第6章 过 滤 数 据 
在SELECT语句中，数据根据WHERE子句中指定的搜索条件进行过滤。WHERE子句在表名（FROM子句）之后给出；

WHERE子句的位置：在同时使用ORDER BY和WHERE子句时，应该让ORDER BY位于WHERE之后，否则将会产生错误

WHERE子句操作符
= 等于
<> 不等于
!= 不等于
< 小于
<= 小于等于
> 大于
>= 大于等于
BETWEEN 在指定的两个值之间 

select prod_name from products where prod_name = 'fuses'; 不区分大小写

select prod_name , prod_price from products where prod_price BETWEEN 5 and 10; between a and b 范围查询

在创建表时，表设计人员可以指定其中的列是否可以不包含值。在一个列不包含值时，称其为包含空值NULL
select cust_id from customers where cust_email is NULL; 空值检查

第7 章 数 据 过 滤 

为了进行更强的过滤控制，MySQL允许给出多个WHERE子句。这些子
句可以两种方式使用：以AND子句的方式或OR子句的方式使用

AND操作符,用在WHERE子句中的关键字，用来指示检索满足所有给定条件的行。可以添加多个过滤条件，每添加一条就要使用一个AND
select prod_id, prod_price, prod_name from products where vend_id = 1003 and prod_price <= 10; 

OR操作符,指示MySQL检索匹配任一条件的行
select prod_name, prod_price from products where vend_id = 1002 or vend_id = 1003;

计算次序：在WHERE子句中使用圆括号 任何时候使用具有AND和OR操作符的WHERE子句，都应该使用圆括号明确地分组操作符
WHERE可包含任意数目的AND和OR操作符;AND在计算次序中优先级更高
select prod_name, prod_price from products where vend_id = 1003 or vend_id = 1003 and prod_price >= 10;
加圆括号改变优先级
select prod_name, prod_price from products (where vend_id = 1003 or vend_id = 1003) and prod_price >= 10;

IN操作符用来指定条件范\围，范围中的每个条件都可以进行匹配
select prod_name, prod_price from products where vend_id in (1002,1003) order by prod_price;

select prod_name, prod_price from products where vend_id = 1002 or vend_id = 1003 order by prod_price;
IN操作符完成与OR相同的功能
在使用长的合法选项清单时，IN操作符的语法更清楚且更直观。
 在使用IN时，计算的次序更容易管理（因为使用的操作符更少）。
 IN操作符一般比OR操作符清单执行更快。
 IN的最大优点是可以包含其他SELECT语句，使得能够更动态地建
立WHERE子句

NOT操作符:WHERE子句中的NOT操作符有且只有一个功能，那就是否定它之后所跟的任何条件。
select prod_name,prod_price from products where vend_id not in (1002,1003);

第 8 章 用通配符进行过滤 
LIKE是谓词而不是操作符

百分号（%）通配符:%表示任何字符出现任意次数。
select prod_id, prod_name from products where prod_name like 'jet%';

虽然似乎%通配符可以匹配任何东西，但有一个例外，即NULL。即使是WHERE prod_name LIKE '%'也不能匹配
用值NULL作为产品名的行;

下划线（_）通配符:只匹配单个字符
select prod_id, prod_name from products where prod_name like '_ ton anvil';

使用通配符要记住:
 不要过度使用通配符。如果其他操作符能达到相同的目的，应该
使用其他操作符。
 在确实需要使用通配符时，除非绝对有必要，否则不要把它们用
在搜索模式的开始处。把通配符置于搜索模式的开始处，搜索起
来是最慢的。
 仔细注意通配符的位置。如果放错地方，可能不会返回想要的数据。

第 9 章 用正则表达式进行搜索
REGEXP在列值内进行匹配，如果被匹配的文本在列值中出现，REGEXP将会找到它，相应的行将被返回;

基本字符匹配
MySQL中的正则表达式匹配（自版本3.23.4后）不区分大小写（即，大写和小写都匹配）。为区分大
小写，可使用BINARY关键字
select prod_name from products where prod_name regexp binary 'JetPack .000'; .是正则表达式语言中一个特殊
的字符。它表示匹配任意一个字符

进行OR匹配
select prod_name from products where prod_name regexp '1000|2000';

匹配几个字符之一
select prod_name from products where prod_name REGEXP '[123] Ton' order by prod_name;
[]是另一种形式的OR语句。事实上，正则表达式[123]Ton为[1|2|3]Ton的缩写
select prod_name from products where prod_name REGEXP '1|2|3 Ton' order by prod_name;
匹配的是 1 或 2 或 3 Ton

[^123]匹配除这些字符外的任何东西
select prod_name from products where prod_name REGEXP '[^123] Ton' order by prod_name;

匹配范围 [1-9] [a-z]
select prod_name from products where prod_name REGEXP '[1-9] Ton' order by prod_name;

匹配特殊字符-转义
select prod_name from products where prod_name REGEXP '\\.' order by prod_name;

\\f 换页
\\n 换行
\\r 回车
\\t 制表
\\v 纵向制表

匹配字符类
[:alnum:] 任意字母和数字（同[a-zA-Z0-9]）
[:alpha:] 任意字符（同[a-zA-Z]）
[:blank:] 空格和制表（同[\\t]）
[:cntrl:] ASCII控制字符（ASCII 0到31和127）
[:digit:] 任意数字（同[0-9]）
[:graph:] 与[:print:]相同，但不包括空格
[:lower:] 任意小写字母（同[a-z]）
[:print:] 任意可打印字符
[:punct:] 既不在[:alnum:]又不在[:cntrl:]中的任意字符
[:space:] 包括空格在内的任意空白字符（同[\\f\\n\\r\\t\\v]）
[:upper:] 任意大写字母（同[A-Z]）
[:xdigit:] 任意十六进制数字（同[a-fA-F0-9]）

匹配连在一起的4位数字
select prod_name from products where prod_name REGEXP '[[:digit:]]{4}' order by prod_name;

定位符
^ 文本的开始
$ 文本的结尾
[[:<:]] 词的开始
[[:>:]] 词的结尾
select prod_name from products where prod_name REGEXP '^[0-9\\.]' order by prod_name; 行内文本的开始处开始匹配
^匹配串的开始。因此，^[0-9\\.]只在.或任意数字为串中第一个字符时才匹配它们

^有两种用法。在集合中（用[和]定义），用它来否定该集合，否则，用来指串的开始处；
LIKE和REGEXP的不同在于，LIKE匹配整个串而REGEXP匹配子串。利用定位
符，通过用^开始每个表达式，用$结束每个表达式，可以使REGEXP的作用与LIKE一

//测试正则表达式
select 'hello' regexp [0-9]; mysql 8.0 报错

第 10 章 创建计算字段
在MySQL的SELECT语句中，可使用Concat()函数来拼接两个列。
多数DBMS使用+或||来实现拼接，MySQL则使用Concat()函数来实现。当把SQL语句转换成
MySQL语句时一定要把这个区别铭记在心；

select Concat(vend_name, ' (', vend_country, ') ')
from vendors
order by vend_name;

RTrim()函数去掉值右边的所有空格
select Concat(RTrim(vend_name), ' (', RTrim(vend_country), ') ')
from vendors
order by vend_name;

as 别名
select Concat(vend_name, ' (', vend_country, ') ') as vend_title
from vendors
order by vend_name;

执行算术计算
select prod_id, quantity, item_price, quantity*item_price AS expanded_price 
from orderitems 
where order_num = 20005;

MySQL算术操作符:
+ 加
- 减
* 乘
/ 除

测试计算：
select 3*2;

第 11 章
使用数据处理函数:

表11-1 常用的文本处理函数
Left() 返回串左边的字符
Length() 返回串的长度
Locate() 找出串的一个子串
Lower() 将串转换为小写
LTrim() 去掉串左边的空格
Right() 返回串右边的字符
RTrim() 去掉串右边的空格
Soundex() 返回串的SOUNDEX值
SubString() 返回子串的字符
Upper() 将串转换为大写

日期和时间处理函数
AddDate() 增加一个日期（天、周等）
AddTime() 增加一个时间（时、分等）
CurDate() 返回当前日期
CurTime() 返回当前时间
Date() 返回日期时间的日期部分
DateDiff() 计算两个日期之差
Date_Add() 高度灵活的日期运算函数
Date_Format() 返回一个格式化的日期或时间串
Day() 返回一个日期的天数部分
DayOfWeek() 对于一个日期，返回对应的星期几
Hour() 返回一个时间的小时部分
Minute() 返回一个时间的分钟部分
Month() 返回一个日期的月份部分
Now() 返回当前日期和时间
Second() 返回一个时间的秒部分
Time() 返回一个日期时间的时间部分
Year() 返回一个日期的年份部分

不管是插入或更新表值还是用WHERE子句进行过滤，日期必须为
格式yyyy-mm-dd

如果你想要的仅是日期，
则使用Date()是一个良好的习惯，即使你知道相应的列只包
含日期也是如此。这样，如果由于某种原因表中以后有日期和
时间值，你的SQL代码也不用改变。当然，也存在一个Time()
函数，在你只想要时间时应该使用它
select cust_id, order_num 
from orders 
where Date(order_date) = '2005-09-01';

检索出2005年9月下的所有订单:
select cust_id, order_num 
from orders 
where Date(order_date) between '2005-09-01' and '2005-09-30';

select cust_id, order_num 
from orders 
where Year(order_date) = 2005 and Month(order_date)=9;

数值处理函数
Abs() 返回一个数的绝对值
Cos() 返回一个角度的余弦
Exp() 返回一个数的指数值
Mod() 返回除操作的余数
Pi() 返回圆周率
Rand() 返回一个随机数
Sin() 返回一个角度的正弦
Sqrt() 返回一个数的平方根
Tan() 返回一个角度的正切

第12 章汇 总 数 据
聚集函数
AVG() 返回某列的平均值
COUNT() 返回某列的行数
MAX() 返回某列的最大值
MIN() 返回某列的最小值
SUM() 返回某列值之和

select avg(prod_price) AS avg_price 
from products
where vend_id = 1003;

COUNT()函数有两种使用方式。
􀂉 使用COUNT(*)对表中行的数目进行计数，不管表列中包含的是空
值（NULL）还是非空值。
􀂉 使用COUNT(column)对特定列中具有值的行进行计数，忽略
NULL值。

select COUNT(*) as cust_num from customers; 
select COUNT(cust_email) as cust_num from customers;

select MAX(prod_price) as  max_price from products;

SUM()用来返回指定列值的和（总计）。
select SUM(quantity) as item_ordered 
from orderitems
where order_num = 20005;

用于计算
select SUM(item_price * quantity) as total_price 
from orderitems
where order_num = 20005;

聚集不同值
select avg(distinct prod_price) AS avg_price 
from products
where vend_id = 1003;


第13 章 分 组 数 据
select vend_id, count(*)  as num_prods
from products
group by vend_id;

with rollup 汇总各分组的和
select vend_id, count(*)  as num_prods
from products
group by vend_id WITH ROLLUP;

在具体使用GROUP BY子句前，需要知道一些重要的规定。
 GROUP BY子句可以包含任意数目的列。这使得能对分组进行嵌套，
为数据分组提供更细致的控制。
 如果在GROUP BY子句中嵌套了分组，数据将在最后规定的分组上
进行汇总。换句话说，在建立分组时，指定的所有列都一起计算
（所以不能从个别的列取回数据）。
 GROUP BY子句中列出的每个列都必须是检索列或有效的表达式
（但不能是聚集函数）。如果在SELECT中使用表达式，则必须在
GROUP BY子句中指定相同的表达式。不能使用别名。
 除聚集计算语句外，SELECT语句中的每个列都必须在GROUP BY子
句中给出。
 如果分组列中具有NULL值，则NULL将作为一个分组返回。如果列
中有多行NULL值，它们将分为一组。
 GROUP BY子句必须出现在WHERE子句之后，ORDER BY子句之前。

过滤分组
除了能用GROUP BY分组数据外，MySQL还允许过滤分组，规定包括
哪些分组，排除哪些分组；
WHERE没有分组的概念；

HAVING非常类似于WHERE。事实上，目前为止所
学过的所有类型的WHERE子句都可以用HAVING来替代。唯一的差别是
WHERE过滤行，而HAVING过滤分组。

WHERE在数据分组前进行过滤，HAVING在数据分组后进行过滤
select vend_id, COUNT(*) as num_prods 
from products
where prod_price >=10 
group by vend_id 
having count(*) >=2;

一般在使用GROUP BY子句时，应该也给
出ORDER BY子句。这是保证数据正确排序的唯一方法。千万
不要仅依赖GROUP BY排序数据
select order_num, sum(quantity*item_price) as ordertotal
from orderitems
group by order_num 
having sum(quantity*item_price) >= 50
order by ordertotal;

SELECT子句及其顺序
子 句          说 明               是否必须使用
SELECT   要返回的列或表达式           是
FROM    从中检索数据的表        仅在从表选择数据时使用
WHERE     行级过滤                     否
GROUP BY   分组说明           仅在按组计算聚集时使用
HAVING     组级过滤                   否
ORDER BY  输出排序顺序                否
LIMIT    要检索的行数                 否


第 14 章

14.2 利用子查询进行过滤
select cust_name, cust_contact 
from customers
where cust_id in (select cust_id 
                  from orders
                  where order_num in (select order_num
                                      from orderitems 
                                      where prod_id = 'TNT2') );

相关子查询:比较orders表中的cust_id与当前正从customers表中检索的cust_id
select cust_name, cust_state,
       (select COUNT(*) 
        from orders 
        where orders.cust_id = customers.cust_id  ) as orders 
        from customers 
        order by cust_name;

逐渐增加子查询来建立查询 用子查询测试和调试查询很有
技巧性，特别是在这些语句的复杂性不断增加的情况下更是如
此。用子查询建立（和测试）查询的最可靠的方法是逐渐进行，
这与MySQL处理它们的方法非常相同。首先，建立和测试最
内层的查询。然后，用硬编码数据建立和测试外层查询，并且
仅在确认它正常后才嵌入子查询。这时，再次测试它。对于要
增加的每个查询，重复这些步骤。这样做仅给构造查询增加了
一点点时间，但节省了以后（找出查询为什么不正常）的大量
时间，并且极大地提高了查询一开始就正常工作的可能性。


第15 章  联 结 表

创建联结
联结的创建非常简单，规定要联结的所有表以及它们如何关联即可。