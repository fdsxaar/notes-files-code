第六章 接口、lambda表达式 与内部类

6 . 1 接口
6 . 1.1 接口概念
public interface Comparable
{
   int compareTo(Object other) ;
}

在JavaSE 5.0 中，Comparable 接口已经改进为泛型类型。
public interface Comparable<T>
{
   int compareTo(T other) ; / / parameter has type T
}

接口中的所有方法自动地属于public。因此， 在接口中声明方法时， 不必提供关键字
public；在实现接口时， 必须把方法声明为pubHc; 否则， 编译器
将认为这个方法的访问属性是包可见性， 即类的默认访问属性，之后编译器就会给出试
图提供更严格的访问权限的警告信息

接口绝不能含有实例域， 在JavaSE 8 之前， 也不能在接口中实现方法

为了让类实现一个接口， 通常需要下面两个步骤：
1 ) 将类声明为实现给定的接口。
2 ) 对接口中的所有方法进行定义。
要将类声明为实现某个接口， 需要使用关键字implements:
class Employee iipleients Comparable

可以为泛型Comparable 接口提供一个类型参数。
class Employee implements Coniparable< Employee>{
    public int compareTo(Employee other){
        return Double.compare(salary, other.salary) ;
    }
}

id1-id2
如果能够确信ID 为非负整数， 或者它们的绝对值不会超过（Integer_MAX_
VALUE-1)/2, 就不会出现问题。否则， 调用静态Integer.compare 方法..

巧不适用于浮点值。因为在salary 和other.salary 很接近但又不
相等的时候， 它们的差经过四舍五入后有可能变成0。x < y 时， Double.compare(x, y) 调
用会返回-1 ; 如果x > y 则返回1。

p216 ??

6.1.2 接口的特性
接口不是类，不能使用new 运算符实例化一个接口：
x = new Comparable(. . .); // ERROR
能声明接口的变量：
Comparable x; // OK
接口变量必须引用实现了接口的类对象：
x = new Employee(. . .); // OK provided Employee implements Comparable
使用instance 检查一个对象是否实现了某个特定的接口：
if (anObject instanceof Comparable) { . . . }
接口也可以被扩展
虽然在接口中不能包含实例域或静态方法，但却可以包含常量。
public interface Powered extends Moveable
{
   double milesPerCallonO;
   double SPEED.LIHIT = 95; // a public static final constant
}
接口中的域将被自动设为public static final。

尽管每个类只能够拥有一个超类， 但却可以实现多个接口
class Employee implements Cloneable, Comparable

6.1.3 接口与抽象类
使用抽象类表示通用属性存在这样一个问题： 每个类只能扩展于一个类。
接口可以提供多重继承的大多数好处，同时还能避免多重继承的复杂性和低效性。

6.1.4 静态方法
在Java SE 8 中，允许在接口中增加静态方法。理论上讲，没有任何理由认为这是不合法
的。只是这有违于将接口作为抽象规范的初衷。

通常的做法都是将静态方法放在伴随类中

6.1.5 默认方法
可以为接口方法提供一个默认实现。必须用default 修饰符标记这样一个方法。
public interface Comparable<T>
default int compareTo(T other) { return 0; }
// By default, all elements are the same

默认方法可以调用任何其他方法。
public interface Collection
{
int size() ; // An abstract method
default boolean isEmptyO
{
return sizeO = 0;
} . .
}

在JavaAPI 中， 你会看到很多接口都有相应的伴随类，这个伴随类中实现了相应接
口的部分或所有方法， 如CoUection/AbstractCollectkm 或MouseListener/MouseAdapter。在
JavaSE 8 中， 这个技术已经过时。现在可以直接在接口中实现方法。

为接口增加一个非默认方法不能保证“ 源代码兼容,jar文件仍然兼容(二进制兼容)
将方法实现为一个默认方法就可以解决这两个问题；

6.1.6 解决默认方法冲突
#讲解不清楚
规则如下：
1 ) 超类优先。如果超类提供了一个具体方法， 同名而且有相同参数类型的默认方法会
被忽略。
2 ) 接口冲突。如果一个超接口提供了一个默认方法， 另一个接口提供了一个同名而且
参数类型（不论是否是默认参数）相同的方法， 必须覆盖这个方法来解决冲突。

6 . 2 接□示例
6 . 2.1 接口与回调
在java.swing 包中有一个Timer 类，可以使用它在到达给定的时间间隔时发出通告

要按长度比较字符串， 可以如下定义一个实现Comparator<String> 的类：
class LengthComparator implements Comparator<String>
{
    public int compare(String first, String second) {
        return first.lengthO - second.lengthO；
    }
}
具体完成比较时，需要建立一个实例：
Comparator<String> comp = new LengthComparator。；
if (conp.compare(words[i], words[j]) > 0) . . .
将这个调用与words[i].compareTo(words[j]) 做比较。这个compare 方法要在比较器对象
上调用， 而不是在字符串本身上调用

#讲解不清楚
6.2.3 对象克隆
clone 方法是Object 的一个protected 方法， 这说明你的代码不能
直接调用这个方法。只有Employee 类可以克隆Employee 对象。这个限制是有原因的。想想
看Object 类如何实现clone。它对于这个对象一无所知， 所以只能逐个域地进行拷贝。如果
对象中的所有数据域都是数值或其他基本类型，拷贝这些域没有任何问题、但是如果对象包
含子对象的引用，拷贝域就会得到相同子对象的另一个引用

浅拷贝会有什么影响吗？ 这要看具体情况。如果原对象和浅克隆对象共享的子对象是不
可变的， 那么这种共享就是安全的。如果子对象属于一个不可变的类， 如String, 就是这种
情况。或者在对象的生命期中， 子对象一直包含不变的常量， 没有更改器方法会改变它， 也
没有方法会生成它的引用，这种情况下同样是安全的

对于每一个类，需要确定：
1 ) 默认的clone 方法是否满足要求；
2 ) 是否可以在可变的子对象上调用clone 来修补默认的clone 方法；
3 ) 是否不该使用clone0
实际上第3 个选项是默认选项。如果选择第1 项或第2 项，类必须：
1 ) 实现Cloneable 接口；
2 ) 重新定义clone 方法，并指定public 访问修饰符。

子类只能调用受保护的clone方法来克隆它自己的对象 //???

//???
在这里， Cloneable 接口的出现与接口的正常使用并没有关系。具体来说， 它没有指定
done 方法，这个方法是从Object 类继承的。这个接口只是作为一个标记，指示类设计者了
解克隆过程。对象对于克隆很“ 偏执”， 如果一个对象请求克隆， 但没有实现这个接口， 就
会生成一个受査异

标记接口不包含任何方法； 它唯一的作用就是允许
在类型查询中使用instanceof:
if (obj instanceof Cloneable) . . .

即使clone 的默认（浅拷贝）实现能够满足要求， 还是需要实现Cloneable 接口， 将clone
重新定义为public， 再调用super.clone()。 下面给出一个例子：
cl ass Employee implements Cloneable{
// raise visibility level to public, change return type
public Employee clone() throws CloneNotSupportedException
    {return (Employee) super.clone() ;
    }
}

协变返回类型//???

如果在一个对象上调用clone, 但这个对象的类并没有实现Cloneable 接口， Object 类
的clone 方法就会拋出一个CloneNotSupportedExceptionD

所有数组类型都有一个public 的clone 方法， 而不是protected: 可以用这个方法
建立一个新数组， 包含原数组所有元素的副本。例如：
int[] luckyNumbers = { 2, 3, 5, 7, 11, 13 };
int[] cloned = luckyNumbers.doneO;
cloned[5] = 12; // doesn't change luckyNumbers[5]

6.3 lambda 表达式现
6.3.2 lambda 表达式的语法
带参数变量的表达式就被称为lambda 表达式

lambda 表达式形式：参数， 箭头（->) 以及一个表达式
即使lambda 表达式没有参数， 仍然要提供空括号
如果可以推导出一个lambda 表达式的参数类型，则可以忽略其类型
Comparator<String> comp
= (first, second) // Same as (String first, String second)
-> first.lengthO - second.lengthO;

无需指定lambda 表达式的返回类型。lambda 表达式的返回类型总是会由上下文推导得
出

6 . 3.3 函数式接口
对于只有一个抽象方法的接口， 需要这种接口的对象时， 就可以提供一个lambda 表达
式。这种接口称为函数式接口（ functional interface )。

接口完全有可能重新声明Object 类的方法， 如toString 或clone,
这些声明有可能会让方法不再是抽象的;

lambda 表达式可以传递到函数式接口。

不能把丨ambda 表达式赋■给类型为Object 的变量，Object 不是一个函数式接口。

java.util.function 包中有一个尤其有用的接口Predicate:
public interface Predicate<T>
{
boolean test(T t);
// Additional default and static methods
}
这个接口专门用来传递
lambda 表达式

6 . 3.4 方法引用 //???
Timer t = new Timer(1000, Systei.out::println) ;
表达式System.out::println 是一个方法引用（ method reference ), 它等价于lambda 表达式
x 一> System.out.println(x)

从这些例子可以看出， 要用：:
操作符分隔方法名与对象或类名。主要有3 种情况：
•object::instanceMethod
•Class::staticMethod
•Class/.instanceMethod
在前2 种情况中， 方法引用等价于提供方法参数的lambda 表达式。前面已经提到，
System.out::println 等价于x -> System.out.println(x)。 类似地，Math::pow 等价于（x，y) ->
Math.pow(x, y)。
对于第3 种情况， 第1 个参数会成为方法的目标。例如，String::compareToIgnoreCase 等
同于(x, y) -> x.compareToIgnoreCase(y)

6 . 3.5 构造器引用
构造器引用与方法引用很类似，只不过方法名为new。例如，Person::new 是Person 构造
器的一个引用

可以用数组类型建立构造器引用。例如， int[]::new 是一个构造器引用， 它有一个参数：
即数组的长度。这等价于lambda 表达式x-> new int[x]

Person口people = stream.toArray(PersonD::new) :
toArray 方法调用这个构造器来得到一个正确类型的数组

lambda 表达式有3
个部分：
1 ) 一个代码块；
2 ) 参数;
3 ) 自由变量的值， 这是指非参数而且不在代码中定义的变量
表示lambda 表达式的数据
结构必须存储自由变量的值，
我们说它被lambda 表达式捕获；

在Java 中， lambda 表达式就是闭包；
lambda 表达式中捕获的变量必须实际上是最终变量( effectivelyfinal）

lambda 表达式的体与嵌套块有相同的作用域。这里同样适用命名冲突和遮蔽的有关规
则。在lambda 表达式中声明与一个局部变量同名的参数或局部变量是不合法的。
Path first = Paths.get(7usr/Mn");
Couparator<String> comp =
(first , second) -> first.length() - second.lengthO ;
II Error: Variable first already defined

使用lambda 表达式的重点是延迟执行deferred execution )

6.3.8 再谈Comparator
静态comparing 方法取一个“ 键提取器” 函数， 它将类型T 映射为一个可比较的类型
( 如String )。对要比较的对象应用这个函数， 然后对返回的键完成比较。例如， 假设有一个
Person 对象数组，可以如下按名字对这些对象排序：
Arrays.sort(people, Comparator.comparing(Person::getName)) ;

6.4 内部类
•内部类方法可以访问该类定义所在的作用域中的数据， 包括私有的数据。
•内部类可以对同一个包中的其他类隐藏起来。
•当想要定义一个回调函数且不想编写大量代码时，使用匿名（anonymous) 内部类比较
便捷。

内部类的对象有一个隐式引用， 它引用了实例化该内部对象的外围类对象。通
过这个指针， 可以访问外围类对象的全部状态，
在Java 中，static 内部类没有这种附加指针，

6.4.1 使用内部类访问对象状态
imePrinter 类声明为私有的。这样一来， 只有TalkingClock 的方法才能够构造
TimePrinter 对象。只有内部类可以是私有类，而常规类只可以具有包可见性，或公有可见性
public class TalkingClock
{
  private int interval:
  private boolean beep;
  public TalkingClock(int interval , boolean beep) { . . . }
  public void start0 { • . . }
  public class TimePrinter implements ActionListener
  // an inner class
    {
        //
    }
}

当在start 方法中创建了TimePrinter 对象后， 编译器就会将this 引用传递给当前的语音
时钟的构造器：
ActionListener listener = new TimePrinter(this); // parameter automatically added

使用外围类引用的
正规语法还要复杂一些。表达式
OwterClass.this
表示外围类引用。例如，可以像下面这样编写TimePrinter 内部类的actionPerformed 方法：
public void actionPerformed(ActionEvent event)
{
   if (TalkingClock.this,beep) Toolkit.getDefaultToolkitO.beep() ;
}

可以采用下列语法格式更加明确地编写内部对象的构造器：
outerObject.n&H InnerClass{construction parameters)
例如，
ActionListener listener = this.new TimePrinterO;

通常，this 限定词是多余的。不过，可以通过显式地命名
将外围类引用设置为其他的对象。例如， 如果TimePrinter 是一个公有内部类，对于任意的语
音时钟都可以构造一个TimePrinter：
TalkingClock jabberer = new Ta1kingClock(1000, true) ;
TalkingOock.TiiePrinter listener = jabberer.new TimePrinterO；
需要注意， 在外围类的作用域之外，可以这样引用内部类：
OuterClass.InnerClass

内部类中声明的所有静态域都必须是final。原因很简单。我们希望一个静态域只
有一个实例， 不过对于每个外部对象， 会分别有一个单独的内部类实例。如果这个域不
是final , 它可能就不是唯一的。
内部类不能有static 方法。Java 语言规范对这个限制没有做任何解释。也可以允许有
静态方法， 但只能访问外围类的静态域和方法

6.4.3 内部类是否有用、必要和安全
内部类是一种编译器现象， 与虚拟机无
关。编译器将会把内部类翻译成用$ ( 美元符号）分隔外部类名与内部类名的常规类文件， 而
虚拟机则对此一无所知

内部类可以访问外围类的私有数据，
由于内部类拥有访问特权， 所以与常规类比较起来功能更加强大

6.4.4 局部内部类
可以在一个方法中定义局部类,
public void start(){
    class C{
        //
    }
}
局部类不能用public 或private 访问说明符进行声明。它的作用域被限定在声明这个局部
类的块中。
局部类有一个优势， 即对外部世界可以完全地隐藏起来。即使TalkingClock 类中的其他
代码也不能访问它。除start 方法之外， 没有任何方法知道TimePrinter 类的存在。

6.4.5 由外部方法访问变量
与其他内部类相比较， 局部类还有一个优点。它们不仅能够访问包含它们的外部类， 还
可以访问局部变量。不过， 那些局部变量必须事实上为final。这说明， 它们一旦赋值就绝不
会改变。

局部类的方法只可以引用定义为final 的局部变量

p252???

6.4.6 匿名内部类
假如只创建这个类的一个对象，就不必命名了。这种类被称为匿名内部类（anonymous inner class)。
public void start(int interval, boolean beep)
{
  ActionListener listener = new ActionListener()
  {
    public void actionPerformed(ActionEvent event)
    {
        System.out.println("At the tone, the time is " + new DateO)；
        if (beep) Toolkit.getDefaultToolkit().beep();
    }
}；
    Timer t = new Timer(interval, listener);
    t.start0；
}
创建一个实现ActionListener 接口的类的新
对象，需要实现的方法actionPerformed 定义在括号内。

通常的语法格式为：
new SuperType(construction parameters)
{
   inner class methods and data
}
其中， SuperType 可以是ActionListener 这样的接口， 于是内部类就要实现这个接口。
SuperType 也可以是一个类，于是内部类就要扩展它。
由于构造器的名字必须与类名相同， 而匿名类没有类名， 所以， 匿名类不能有构造器。
取而代之的是，将构造器参数传递给超类（ superclass) 构造器。尤其是在内部类实现接口的
时候， 不能有任何构造参数
new InterfaceType{
    methods and data
}

多年来，Java 程序员习惯的做法是用匿名内部类实现事件监听器和其他回调。如今最好
还是使用lambda 表达式

invite(new ArrayList<String>0 {{ add("Harry") ; add("Tony") ; }}) ;//???

if (getClassO != other.getClassO) return false;
对匿名子类做这个测试时会失败；

生成曰志或调试消息时， 通常希望包含当前类的类名， 如：
Systen.err.println("Something awful happened in " + getClassO)；
不过， 这对于静态方法不奏效。毕竟， 调用getClass 时调用的是this.getClassO, 而
静态方法没有this。所以应该使用以下表达式：
new Object0{}.getCIass0-getEndosingClass0 // gets class of static method
在这里，newObject0{} 会建立Object 的一个匿名子类的一个匿名对象，getEnclosingClass
则得到其外围类， 也就是包含这个静态方法的类。

6.4.7 静态内部类
有时候， 使用内部类只是为了把一个类隐藏在另外一个类的内部，并不需要内部类引用
外围类对象。为此，可以将内部类声明为static, 以便取消产生的引用。

//找出数组中的最大值最小值
double min = Double .POSITIVE_INFINITY;
double max = Double.NECATIVE.INFINITY;
for (double v : values)
{
   if (min > v) min = v;
   if (max < v) max = v;
}

//对照p256代码
当然， Pair 是一个十分大众化的名字。在大型项目中， 除了定义包含一对字符串的Pair
类之外， 其他程序员也很可能使用这个名字。这样就会产生名字冲突。解决这个问题的办法
是将Pair 定义为ArrayAlg 的内部公有类

//p257???
静态内部类的对象除了没有对生成它的外围类对象的引用特权外， 与其他所冇内部类完全一样。
在我们列举的示例中， 必须使用静态内部类，这是由于内部类对象是在静态方法中构造的

在内部类不需要访问外围类对象的时候， 应该使用静态内部类。有些程序员用嵌
套类（nested class ) 表示静态内部

与常规内部类不同， 静态内部类可以有静态域和方法。

声明在接口中的内部类自动成为static 和public 类

//没看
6.5 代理
6.5.1 何时使用代理

