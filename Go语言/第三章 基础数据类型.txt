第三章 基础数据类型

Go’s types fall into four categories: basic ty pes, aggregate ty pes, reference types, and interface
types. 
引用类型包括指针（§2.3.2）、切片（§4.2)）字典（§4.3）、函数（§5）、通道（§8），虽然数据种类很多，但它们都是
对程序中一个变量或状态的间接引用。

3.1. 整型
这里还有两种一般对应特定CPU平台机器字大小的有符号和无符号整数int和uint；其中int是应用最
广泛的数值类型。这两种类型都有同样的大小，32或64bit，但是我们不能对此做任何的假设；因
为不同的编译器即使在相同的硬件平台上可能产生不同的大小。

Unicode字符rune类型是和int32等价的类型，通常用于表示一个Unicode码点。这两个名称可以互
换使用。同样byte也是uint8类型的等价类型，byte类型一般用于强调数值是一个原始的数据而不是
一个小的整数。

最后，还有一种无符号的整数类型uintptr，没有指定具体的bit大小但是足以容纳指针。uintptr类型
只有在底层编程时才需要，特别是Go语言和C语言函数库或操作系统接口相交互的地方。

Regardless of their size, int, uint, and uintptr are dif ferent typ es from their explicitly size d
siblings. Thus int is not the same type as int32, even if the natural size of int egers is 32 bits,
and an explicit conversion is required to use an int value where an int32 is needed, and vice
versa.

在Go语言中，%取模运算符的符号和被取模数的符号总是一致的，因此‐5%3 和‐5%‐3 结果都是2。除法运算符/ 的行为则依赖
于操作数是否为全为整数，比如5.0/4.0 的结果是1.25，但是5/4的结果是1，因为整数除法会向着0方向截断余数

按照优先级递减的顺序的排列：
* / % << >> & &^
+ ‐ | ^
== != < <= > >=
&&
||

溢出
var u uint8 = 255
fmt.Println(u, u+1, u*u) // "255 0 1"
var i int8 = 127
fmt.Println(i, i+1, i*i) // "127 ‐128 1"

一元的加法和减法运算符：
+ 一元加法 (无效果)
‐ 负数
对于整数，+x是0+x的简写，x则是0-x的简写；对于浮点数和复数，+x就是x，-x则是x的负数。

位操作运算符^ 作为二元运算符时是按位异或（XOR），当用作一元运算符时表示按位取反；也就
是说，它返回一个每个bit位都取反的数。位操作运算符&^ 用于按位置零（AND NOT）：如果对应
y中bit位为1的话, 表达式z = x &^ y 结果z的对应的bit位为0，否则z对应的bit位等于x相应的bit位的
值。

x<<n 和x>>n 移位运算，n的位置

左移运算用零填充右边空缺的bit位，无符号数的右移运算也是用0填充左边空缺的bit位，但是有符
号数的右移运算会用符号位的值填充左边空缺的bit位。因为这个原因，最好用无符号运算，这样你
可以将整数完全当作一个bit位模式处理

尽管Go语言提供了无符号数和运算，即使数值本身不可能出现负数我们还是倾向于使用有符号的
int类型，就像数组的长度那样，虽然使用uint无符号类型似乎是一个更合理的选择。事实上，内置
的len函数返回一个有符号的int

许多整数之间的相互转换并不会改变数值；它们只是告诉编译器如何解释这个值
浮点数到整数的转换将丢失任何小数部分，然后向数轴零方向截断
f := 3.141 // a float64
i := int(f)
fmt.Println(f, i) // "3.141 3"
f = 1.99
fmt.Println(int(f)) // "1"

%之后的[1] 副词告诉Printf函数再次使用第一个操作数。第二，%后的# 副词告诉
Printf在用%o、%x或%X输出时生成0、0x或0X前缀
o := 0666
fmt.Printf("%d %[1]o %#[1]o\n", o) // "438 666 0666"
x := int64(0xdeadbeef)
fmt.Printf("%d %[1]x %#[1]x %#[1]X\n", x)
// Output:
// 3735928559 deadbeef 0xdeadbeef 0XDEADBEEF

[打印汉字]
字符面值通过一对单引号直接包含对应字符。最简单的例子是ASCII中类似'a'写法的字符面值，但
是我们也可以通过转义的数值来表示任意的Unicode码点对应的字符
字符使用%c 参数打印，或者是用%q 参数打印带单引号的字符：
ascii := 'a'
unicode := '国'
newline := '\n'
fmt.Printf("%d %[1]c %[1]q\n", ascii) // "97 a 'a'"
fmt.Printf("%d %[1]c %[1]q\n", unicode) // "22269 国 '国'"
fmt.Printf("%d %[1]q\n", newline) // "10 '\n'"

3.2. 浮点数
Go语言提供了两种精度的浮点数，float32和float64
这些浮点数类型的取值范围可以从很微小到很巨大。浮点数的范围极限值可以在math包找到。常量
math.MaxFloat32表示float32能表示的最大数值，大约是 3.4e38；对应的math.MaxFloat64常量大
约是1.8e308。它们分别能表示的最小值近似为1.4e45
和4.9e324

【一个float32类型的浮点数可以提供大约6个十进制数的精度，而float64则可以提供约15个十进制数
的精度；】通常应该优先使用float64类型，因为float32类型的累计计算误差很容易扩散，并且float32
能精确表示的正整数并不是很大

var f float32 = 16777216 // 1 << 24
fmt.Println(f == f+1) // "true"!
浮点数的字面值可以直接写小数部分，像这样：
const e = 2.71828 // (approximately)
小数点前面或后面的数字都可能被省略（例如.707或1.）。很小或很大的数最好用科学计数法书
写，通过e或E来指定指数部分：
const Avogadro = 6.02214129e23 // 阿伏伽德罗常数
const Planck = 6.62606957e‐34 // 普朗克常数

用Printf函数的%g参数打印浮点数，将采用更紧凑的表示形式打印，并提供足够的精度，但是对应
表格的数据，使用%e（带指数）或%f的形式打印可能更合适

math包中除了提供大量常用的数学函数外，还提供了IEEE754浮点数标准中定义的特殊值的创建和
测试：正无穷大和负无穷大，分别用于表示太大溢出的数字和除零的结果；还有NaN非数，一般用
于表示无效的除法操作结果0/0或Sqrt(1).
【注】除零，无穷大；0/0，结果是NaN；
var z float64
fmt.Println(z, ‐z, 1/z, ‐1/z, z/z) // "0 ‐0 +Inf ‐Inf NaN"

函数math.IsNaN用于测试一个数是否是非数NaN，math.NaN则返回非数对应的值。虽然可以用
math.NaN来表示一个非法的结果，但是测试一个结果是否是非数NaN则是充满风险的，因为NaN
和任何数都是不相等的
nan := math.NaN()
fmt.Println(nan == nan, nan < nan, nan > nan) // "false false false"

如果一个函数返回的浮点数结果可能失败，最好的做法是用单独的标志报告失败，像这样：
func compute() (value float64, ok bool) {
    // ...
    if failed {
        return 0, false
    }
    return result, true
}

3.3. 复数
Go语言提供了两种精度的复数类型：complex64和complex128，分别由float32和float64两种浮
点数精度构成

如果一个浮点数面值或一个十进制整数面值后面跟着一个i，例如3.141592i或2i，它将构成一个复
数的虚部，复数的实部是0

复数也可以用==和!=进行相等比较。只有两个复数的实部和虚部都相等的时候它们才是相等的（译
注：浮点数的相等比较是危险的，需要特别小心处理精度问题）。

math/cmplx包提供了复数处理的许多函数

3.4. 布尔型
一个布尔类型的值只有两种：true和false。if和for语句的条件部分都是布尔类型的值，并且==和<
等比较操作也会产生布尔型的值

布尔值可以和&&（AND）和||（OR）操作符结合，并且有短路行为：如果运算符左边值已经可以
确定整个布尔表达式的值，那么运算符右边的值将不再被求值，因此下面的表达式总是安全的：
s != "" && s[0] == 'x'
其中s[0]操作如果应用于空字符串将会导致panic异常。
因为&& 的优先级比|| 高（助记： && 对应逻辑乘法， || 对应逻辑加法，乘法比加法优先级要高）

3.5字符串
一个字符串是一个不可改变的字节序列
内置的len函数可以返回一个字符串中的字节数目（不是rune字符数目），索引操作s[i]返回第i个字
节的字节值，i必须满足0 ≤ i< len(s)条件约束。
s := "hello, world"
fmt.Println(len(s)) // "12"
fmt.Println(s[0], s[7]) // "104 119" ('h' and 'w')
如果试图访问超出字符串索引范围的字节将会导致panic异常
c := s[len(s)] // panic: index out of range

子字符串操作s[i:j]基于原始的s字符串的第i个字节开始到第j个字节（并不包含j本身）生成一个新字
符串。生成的新字符串将包含ji
个字节。
fmt.Println(s[0:5]) // "hello"
同样，如果索引超出字符串范围或者j小于i的话将导致panic异常。
不管i还是j都可能被忽略，当它们被忽略时将采用0作为开始位置，采用len(s)作为结束的位置。
fmt.Println(s[:5]) // "hello"
fmt.Println(s[7:]) // "world"
fmt.Println(s[:]) // "hello, world"
其中+操作符将两个字符串链接构造一个新字符串：

fmt.Println("goodbye" + s[5:]) // "goodbye, world"
字符串可以用==和<进行比较；比较通过逐个字节比较完成的，因此比较的结果是字符串自然编码
的顺序。

字符串是不可修改的，因此尝试修改字符串内部数据的操作也是被禁止的。
#用C++语言来说，是常量字符串

不变性意味如果两个字符串共享相同的底层数据的话也是安全的，这使得复制任何长度的字符串代
价是低廉的。同样，一个字符串s和对应的子字符串切片s[7:]的操作也可以安全地共享相同的内
存，因此字符串切片操作代价也是低廉的。在这两种情况下都没有必要分配新的内存
#切片操作引用了原字符串的某个字串

3.5.1. 字符串面值
字符串值也可以用字符串面值方式编写，只要将一系列字节序列包含在双引号即可：
"Hello, 世界"

转义 
\' 单引号 (只用在 '\'' 形式的rune符号面值中) #？
\" 双引号 (只用在 "..." 形式的字符串面值中)
可以通过十六进制或八进制转义在字符串面值包含任意的字节。一个十六进制的转义形式是\xhh，
其中两个h表示十六进制数字（大写或小写都可以）。一个八进制转义形式是\ooo，包含三个八进
制数字（0到7），但是不能超过\377 （译注：对应一个字节的范围，十进制为255）。每一个单一的字节表达一个特定的值

一个原生的字符串面值形式是`...`，使用反引号代替双引号。在原生的字符串面值中，没有转义操
作；全部的内容都是字面的意思，包含退格和换行，因此一个程序中的原生字符串面值可能跨越多
行（译注：在原生字符串面值内部是无法直接写`字符的，可以用八进制或十六进制转义或+"`"链接
字符串常量完成）。唯一的特殊处理是会删除回车以保证在所有平台上的值都是一样的，包括那些
把回车也放入文本文件的系统（译注：Windows系统会把回车和换行一起放入文本文件中）。

原生字符串面值用于编写正则表达式会很方便，因为正则表达式往往会包含很多反斜杠。原生字符
串面值同时被广泛应用于HTML模板、JSON面值、命令行提示信息以及那些需要扩展到多行的场
景。
const GoUsage = `Go is a tool for managing Go source code.
Usage:
go command [arguments]
...`

3.5.2.
0xxxxxxx runes 0‐127 (ASCII) 
110xxxxx 10xxxxxx 128‐2047 (values <128 unused) #11个x，2^11-1,2047
1110xxxx 10xxxxxx 10xxxxxx 2048‐65535 (values <2048 unused) #16个x,2^16-1,65535
11110xxx 10xxxxxx 10xxxxxx 10xxxxxx 65536‐0x10ffff (other values unused)

变长的编码无法直接通过索引来访问第n个字符，但是UTF8编码获得了很多额外的优点。首先
UTF8编码比较紧凑，完全兼容ASCII码，并且可以自动同步：它可以通过向前回朔最多2个字节就
能确定当前字符编码的开始字节的位置。它也是一个前缀编码，所以当从左向右解码时不会有任何
歧义也并不需要向前查看（译注：像GBK之类的编码，如果不知道起点位置则可能会出现歧义）。
没有任何字符的编码是其它字符编码的子串，或是其它编码序列的字串，因此搜索一个字符时只要
搜索它的字节编码序列即可，不用担心前后的上下文会对搜索结果产生干扰。同时UTF8编码的顺
序和Unicode码点的顺序一致，因此可以直接排序UTF8编码序列。同时因为没有嵌入的NUL(0)字
节，可以很好地兼容那些使用NUL作为字符串结尾的编程语言。

Go语言字符串面值中的Unicode转义字
符让我们可以通过Unicode码点输入特殊的字符。有两种形式：\uhhhh对应16bit的码点值，
\Uhhhhhhhh对应32bit的码点值，其中h是一个十六进制数字
"世界"
"\xe4\xb8\x96\xe7\x95\x8c"
"\u4e16\u754c"
"\U00004e16\U0000754c"

Unicode转义也可以使用在rune字符中。下面三个字符是等价的：
'世' '\u4e16' '\U00004e16'
对于小于256码点值可以写在一个十六进制转义字节中，例如'\x41'对应字符'A'，但是对于更大的码
点则必须使用\u或\U转义形式。因此，'\xe4\xb8\x96'并不是一个合法的rune字符，虽然这三个字节
对应一个有效的UTF8编码的码点。

#主要是由于字节序列的内存布局方式；对于UTF8编码后文本的处理和原始的字节处理逻辑是一样的。但是对应很多其它编码则并不是这
#样的。
得益于UTF8编码优良的设计，诸多字符串操作都不需要解码操作。我们可以不用解码直接测试一
个字符串是否是另一个字符串的前缀：
func HasPrefix(s, prefix string) bool {
return len(s) >= len(prefix) && s[:len(prefix)] == prefix
}
或者是后缀测试：
func HasSuffix(s, suffix string) bool {
return len(s) >= len(suffix) && s[len(s)‐len(suffix):] == suffix
}

Go语言的range循环在处理字符串的时候，会自动
隐式解码UTF8字符串

UTF-8解码器，unicode/utf8包提供了该功能，我们可以这样使用：
for i := 0; i < len(s); {
    r, size := utf8.DecodeRuneInString(s[i:])
    fmt.Printf("%d\t%c\n", i, r)
    i += size
}

Go语言的range循环在处理字符串的时候，会自动隐式解码UTF8字符串
for i, r := range "Hello, 世界" {
    fmt.Printf("%d\t%q\t%d\n", i, r, r)
}

我们可以使用一个简单的循环来统计字符串中字符的数目，像这样：
n := 0
for _, _ = range s {
n++
}

像其它形式的循环那样，我们也可以忽略不需要的变量：
n := 0
for range s {
    n++
}
或者我们可以直接调用utf8.RuneCountInString(s)函数。

正如我们前面提到的，文本字符串采用UTF8编码只是一种惯例，但是对于range循环，则必须要求，
而不是按照惯例。如果utf-8编码的字符串中包含错误的编码字符，则发生什么？

每一个UTF8字符解码，不管是显式地调用utf8.DecodeRuneInString解码或是在range循环中隐式
地解码，如果遇到一个错误的UTF8编码输入，将生成一个特别的Unicode字符'\uFFFD'，在印刷中
这个符号通常是一个黑色六角或钻石形状，里面包含一个白色的问号；

UTF8字符串作为交换格式是非常方便的，但是在程序内部采用rune序列可能更方便，因为rune大
小一致，支持数组索引和方便切割。

答案就是使用Unicode（ http://unicode.org ），它收集了这个世界上所有的符号系统，包括重音符
号和其它变音符号，制表符和回车符，还有很多神秘的符号，每个符号都分配一个唯一的Unicode
码点，Unicode码点对应Go语言中的rune整数类型（译注：rune是int32等价类型）

// "program" in Japanese katakana
s := "プログラム"
fmt.Printf("% x\n", s) // "e3 83 97 e3 83 ad e3 82 b0 e3 83 a9 e3 83 a0"
r := []rune(s)
fmt.Printf("%x\n", r) // "[30d7 30ed 30b0 30e9 30e0]"
（在第一个Printf中的% x 参数用于在每个十六进制数字前插入一个空格。）

将一个整数转型为字符串,其值按文字符号类型解读，并且产生代表该文字符号值的utf-8编码：
fmt.Println(string(65)) // "A", not "65"
fmt.Println(string(0x4eac)) // "京"

3.5.4. 字符串和Byte切片
标准库中有四个包对字符串处理尤为重要：bytes、strings、strconv和unicode包。strings包提供了
许多如字符串的查询、替换、比较、截断、拆分和合并等功能。

bytes包也提供了很多类似功能的函数，但是针对和字符串有着相同结构的[]byte类型。因为字符串
是只读的，因此逐步构建字符串会导致很多分配和复制。在这种情况下，使用bytes.Buffer类型将
会更有效，稍后我们将展示。

strconv包提供了布尔型、整型数、浮点数和对应字符串的相互转换，还提供了双引号转义相关的转
换。

unicode包提供了IsDigit、IsLetter、IsUpper和IsLower等类似功能，它们用于给字符分类。每个函
数有一个单一的rune类型的参数，然后返回一个布尔值。而像ToUpper和ToLower之类的转换函数
将用于rune字符的大小写转换。所有的这些函数都是遵循Unicode标准定义的字母、数字等分类规
范。strings包也有类似的函数，它们是ToUpper和ToLower，将原始字符串的每个字符都做相应的
转换，然后返回新的字符串。

basename(s)将看
起来像是系统路径的前缀删除，同时将看似文件类型的后缀名部分删除：
fmt.Println(basename("a/b/c.go")) // "c"
fmt.Println(basename("c.d.go")) // "c.d"
fmt.Println(basename("abc")) // "abc"

gopl.io/ch3/basename2
func basename(s string) string {
slash := strings.LastIndex(s, "/") // ‐1 if "/" not found
    s = s[slash+1:]
    if dot := strings.LastIndex(s, "."); dot >= 0 {
        s = s[:dot]
}
    return s
}
path和path/filepath包提供了关于文件路径名更一般的函数操作

函数的功能是将一个表示整值的字符串，每隔三个字符插入一个
逗号分隔符，例如“12345”处理后成为“12,345”。这个版本只适用于整数类型；支持浮点数类型的支
持留作练习。
gopl.io/ch3/comma
// comma inserts commas in a non‐negative decimal integer string.
func comma(s string) string {
    n := len(s)
    if n <= 3 {
        return s
}
    return comma(s[:n‐3]) + "," + s[n‐3:]
}
输入comma函数的参数是一个字符串。如果输入字符串的长度小于或等于3的话，则不需要插入逗
分隔符。否则，comma函数将在最后三个字符前位置将字符串切割为两个两个子串并插入逗号分
隔符，然后通过递归调用自身来出前面的子串

A string contains an array of bytes that, once created, isimmut able. By contrast, the elements
of a byte slice can be freely modified
s := "abc"
b := []byte(s) #拷贝创建
s2 := string(b) #拷贝创建
从概念上讲，一个[]byte(s)转换是分配了一个新的字节数组用于保存字符串数据的拷贝，然后引用
这个底层的字节数组。编译器的优化可以避免在一些场景下分配和复制字符串数据，但总的来说需
要确保在变量b被修改的情况下，原始的s字符串也不会改变。将一个字节slice转到字符串的
string(b)操作则是构造一个字符串拷贝，以确保s2字符串是只读的

为了避免转换中不必要的内存分配，bytes包和strings同时提供了许多实用函数。下面是strings包
中的六个函数：
func Contains(s, substr string) bool
func Count(s, sep string) int
func Fields(s string) []string
func HasPrefix(s, prefix string) bool
func Index(s, sep string) int
func Join(a []string, sep string) string
bytes包中也对应的六个函数：
func Contains(b, subslice []byte) bool
func Count(s, sep []byte) int
func Fields(s []byte) [][]byte
func HasPrefix(s, prefix []byte) bool
func Index(s, sep []byte) int
func Join(s [][]byte, sep []byte) []byte

当向bytes.Buffer添加任意字符的UTF8编码时，最好使用bytes.Buffer的WriteRune方法，但是
WriteByte方法对于写入类似'['和']'等ASCII字符则会更加有效。

bytes包还提供了Buffer类型用于字节slice的缓存。一个Buffer开始是空的，但是随着string、byte或
[]byte等类型数据的写入可以动态增长，一个bytes.Buffer变量并不需要初始化，因为零值也是有效
的

3.5.5. 字符串和数字的转换
由strconv包提供这类转换功能。
将一个整数转为字符串，一种方法是用fmt.Sprintf返回一个格式化的字符串；另一个方法是用
strconv.Itoa(“整数到ASCII”)：
x := 123
y := fmt.Sprintf("%d", x)
fmt.Println(y, strconv.Itoa(x)) // "123 123"

FormatInt和FormatUint函数可以用不同的进制来格式化数字：
fmt.Println(strconv.FormatInt(int64(x), 2)) // "1111011"

fmt.Printf函数的%b、%d、%o和%x等参数提供功能往往比strconv包的Format函数方便很多，特
别是在需要包含附加额外信息的时候：
s := fmt.Sprintf("x=%b", x) // "x=1111011"

如果要将一个字符串解析为整数，可以使用strconv包的Atoi或ParseInt函数，还有用于解析无符号
整数的ParseUint函数：
x, err := strconv.Atoi("123") // x is an int
y, err := strconv.ParseInt("123", 10, 64) // base 10, up to 64 bits

ParseInt函数的第三个参数是用于指定整型数的大小；例如16表示int16，0则表示int。在任何情况
下，返回的结果y总是int64类型，你可以通过强制类型转换将它转为更小的整数类型。

有时候也会使用fmt.Scanf来解析输入的字符串和数字，特别是当字符串和数字混合在一行的时
候，它可以灵活处理不完整或不规则的输入。

3.6. 常量
和变量声明一样，可以批量声明多个常量；这比较适合声明一组相关的常量：
const (
e = 2.71828182845904523536028747135266249775724709369995957496696763
pi = 3.14159265358979323846264338327950288419716939937510582097494459
)

所有常量的运算都可以在编译期完成，这样可以减少运行时的工作，也方便其他编译优化。当操作
数是常量时，一些运行时的错误也可以在编译时被发现，例如整数除零、字符串索引越界、任何导
致无效浮点数的操作等

常量间的所有算术运算、逻辑运算和比较运算的结果也是常量，对常量的类型转换操作或以下函数
调用都是返回常量结果：len、cap、real、imag、complex和unsafe.Sizeof（§13.1）

%d 十进制整数
%x, %o, %b 十六进制，八进制，二进制整数。
%f, %g, %e 浮点数： 3.141593 3.141592653589793 3.141593e+00
%t 布尔：true或false
%c 字符（rune） (Unicode码点)
%s 字符串
%q 带双引号的字符串"abc"或带单引号的字符'c'
%v 变量的自然形式（natural format）
%T 变量的类型
%% 字面上的百分号标志（无操作数）

如果是批量声明的常量，除了第一个外其它的常量右边的初始化表达式都可以省略，如果省略初始
化表达式则表示使用前面常量的初始化表达式写法，对应的常量类型也一样的。例如：
const (
    a = 1
    b
    c = 2
    d
)
fmt.Println(a, b, c, d) // "1 1 2 2"

3.6.1. iota 常量生成器
常量声明可以使用iota常量生成器初始化，它用于生成一组以相似规则初始化的常量，但是不用每
行都写一遍初始化表达式。在一个const声明语句中，在第一个声明的常量所在的行，iota将会被置
为0，然后在每一个有常量声明的行加一。
下面是来自time包的例子，它首先定义了一个Weekday命名类型，然后为一周的每天定义了一个常
量，从周日0开始。在其它编程语言中，这种类型一般被称为枚举类型。
type Weekday int
const (
    Sunday Weekday = iota
    Monday
    Tuesday
    Wednesday
    Thursday
    Friday
    Saturday
)

const (
_ = 1 << (10 * iota) #将iota看成一个常量值
KiB // 1024
MiB // 1048576
GiB // 1073741824
TiB // 1099511627776 (exceeds 1 << 32)
PiB // 1125899906842624
EiB // 1152921504606846976
ZiB // 1180591620717411303424 (exceeds 1 << 64)
YiB // 1208925819614629174706176
)

不过iota常量生成规则也有其局限性。例如，它并不能用于产生1000的幂（KB、MB等），因为Go
语言并没有计算幂的运算符。

3.6.2. 无类型常量
#类型待定，精度足够
Go语言的常量有个不同寻常之处。虽然一个常量可以有任意有一个确定的基础类型，例如int或
float64，或者是类似time.Duration这样命名的基础类型，但是许多常量并没有一个明确的基础类
型。编译器为这些没有明确的基础类型的数字常量提供比基础类型更高精度的算术运算；你可以认
为至少有256bit的运算精度。这里有六种未明确类型的常量类型，分别是无类型的布尔型、无类型
的整数、无类型的字符、无类型的浮点数、无类型的复数、无类型的字符串

通过延迟明确常量的具体类型，无类型的常量不仅可以提供更高的运算精度，而且可以直接用于更
多的表达式而不需要显式的类型转换。例如，例子中的ZiB和YiB的值已经超出任何Go语言中整数
类型能表达的范围，但是它们依然是合法的常量，可以用于下面的表达式

另一个例子，math.Pi无类型的浮点数常量，可以直接用于任意需要浮点数或复数的地方：

var x float32 = math.Pi
var y float64 = math.Pi
var z complex128 = math.Pi
如果math.Pi被确定为特定类型，比如float64，那么结果精度可能会不一样，同时对于需要float32
或complex128类型值的地方则会强制需要一个明确的类型转换：
const Pi64 float64 = math.Pi
var x float32 = float32(Pi64)
var y float64 = Pi64
var z complex128 = complex128(Pi64)

对于常量面值，不同的写法可能会对应不同的类型。例如0、0.0、0i和'\u0000'虽然有着相同的常量
值，但是它们分别对应无类型的整数、无类型的浮点数、无类型的复数和无类型的字符等不同的常
量类型。同样，true和false也是无类型的布尔值，字符串面值常量是无类型字符串。

前面说过除法运算符/会根据操作数的类型生成对应类型的结果。因此，不同写法的常量除法表达
式可能对应不同的结果：

前面说过除法运算符/会根据操作数的类型生成对应类型的结果。因此，不同写法的常量除法表达
式可能对应不同的结果
var f float64 = 212
fmt.Println((f ‐ 32) * 5 / 9) // "100"; (f ‐ 32) * 5 is a float64
fmt.Println(5 / 9 * (f ‐ 32)) // "0"; 5/9 is an untyped integer, 0
fmt.Println(5.0 / 9.0 * (f ‐ 32)) // "100"; 5.0/9.0 is an untyped float

只有常量可以是无类型的。当一个无类型的常量被赋值给一个变量的时候，就像下面的第一行语
句，或者出现在有明确类型的变量声明的右边，如下面的其余三行语句，无类型的常量将会被隐式
转换为对应的类型，如果转换合法的话。
var f float64 = 3 + 0i // untyped complex ‐> float64
f = 2 // untyped integer ‐> float64
f = 1e123 // untyped floating‐point ‐> float64
f = 'a' // untyped rune ‐> float64

 #【可能是由于无类型整数有256位的精度，-1的二进制为全为1
f=uint(-1) // compile error: constant underflows uint

对于一个没有显式类型的变量声明（包括简短变量声明），常量的形式将隐式决定变量的默认类
型，就像下面的例子：
i := 0 // untyped integer; implicit int(0)
r := '\000' // untyped rune; implicit rune('\000')
f := 0.0 // untyped floating‐point; implicit float64(0.0)
c := 0i // untyped complex; implicit complex128(0i)
注意有一点不同：无类型整数常量转换为int，它的内存大小是不确定的，但是无类型浮点数和复数
常量则转换为内存大小明确的float64和complex128。 如果不知道浮点数类型的内存大小是很难写
出正确的数值算法的，因此Go语言不存在整型类似的不确定内存大小的浮点数和复数类型。

如果要给变量一个不同的类型，我们必须显式地将无类型的常量转化为所需的类型，或给声明的变
量指定明确的类型
var i = int8(0)
var i int8 = 0

当尝试将这些无类型的常量转为一个接口值时（见第7章），这些默认类型将显得尤为重要，因为
要靠它们明确接口对应的动态类型。
fmt.Printf("%T\n", 0) // "int"
fmt.Printf("%T\n", 0.0) // "float64"
fmt.Printf("%T\n", 0i) // "complex128"
fmt.Printf("%T\n", '\000') // "int32" (rune)


