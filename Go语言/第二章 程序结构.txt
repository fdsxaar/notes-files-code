2.1命名
1.这些内部预先定义的名字并不是关键字，你可以在定义中重新使用它们
内建常量: true false iota nil

内建类型: int int8 int16 int32 int64
uint uint8 uint16 uint32 uint64 uintptr
float32 float64 complex128 complex64
bool byte rune string error

内建函数: make len cap new append copy close delete
complex real imag panic recover

2.如果一个名字是在函数内部定义，那么它的就只在函数内部有效。如果是在函数外部定义，那么将
在当前包的所有文件中都可以访问。名字的开头字母的大小写决定了名字在包外的可见性。如果一
个名字是大写字母开头的（译注：必须是在函数外部定义的包级名字；包级函数名本身也是包级名
字），那么它将是导出的，也就是说可以被外部的包访问，例如fmt包的Printf函数就是导出的，可
以在fmt包外部访问。包本身的名字一般总是用小写字母

3.名字的长度没有逻辑限制，但是Go语言的风格是尽量使用短小的名字，对于局部变量尤其是这
样；你会经常看到i之类的短名字，而不是冗长的theLoopIndex命名。通常来说，如果一个名字的
作用域比较大，生命周期也比较长，那么用长的名字将会更有意义

4.在习惯上，Go语言程序员推荐使用 驼峰式 命名，当名字有几个单词组成的时优先使用大小写分
隔，而不是优先用下划线分隔

2.2 声明
1.Go语言主要有四种类型的声明语句：var、const、type和func，分别对应变量、常量、类型和
函数实体对象的声明包一级的各种类型的声明语句的顺序无关紧要（译注：函数内部的名字则必须
先声明之后才能使用）

其中常量boilingF是在包一级范围声明语句声明的，然后f和c两个变量是在main函数内部声明的声
明语句声明的。在包一级声明语句声明的名字可在整个包对应的每个源文件中访问，而不是仅仅在
其声明语句所在的源文件中访问。相比之下，局部声明的名字就只能在函数内部很小的范围被访
问。

一个函数的声明由一个函数名字、参数列表（由函数的调用者提供参数变量的具体值）、一个可选
的返回值列表和包含函数定义的函数体组成。如果函数没有返回值，那么返回值列表是省略的。执
行函数从函数的第一个语句开始，依次顺序执行直到遇到return返回语句，如果没有返回语句则是
执行到函数末尾，然后返回到函数调用者。
func fToC(f float64) float64 {
return (f ‐ 32) * 5 / 9
}

2.3
<总论，全部>
2.3.1. 简短变量声明

<全部>
这里有一个比较微妙的地方：简短变量声明左边的变量可能并不是全部都是刚刚声明的。如果有一
些已经在相同的词法域声明过了（§2.7），那么简短变量声明语句对这些已经声明过的变量就只有
赋值行为了。

在下面的代码中，第一个语句声明了in和err两个变量。在第二个语句只声明了out一个变量，然后
对已经声明的err进行了赋值操作。
in, err := os.Open(infile)
out, err := os.Create(outfile)

简短变量声明语句中必须至少要声明一个新的变量，下面的代码将不能编译通过：
f, err := os.Open(infile)
f, err := os.Create(outfile) // compile error: no new variables

简短变量声明语句只有对已经在同级词法域声明过的变量才和赋值操作语句等价，如果变量是在外
部词法域声明的，那么简短变量声明语句将会在当前词法域重新声明一个新的变量

2.3.2. 指针
并不是每一个值都会有一个内存地址，但是对于每一个变量必然有对应的内存地址。通过指针，我们可以直接读或更新
对应变量的值，而不需要知道该变量的名字（如果变量有名字的话）

因为简洁和灵活的特点，简短变量声明被广泛用于大部分的局部变量的声明和初始化。var形式的
声明语句往往是用于需要显式指定变量类型地方，或者因为变量稍后会被重新赋值而初始值无关紧
要的地方。

变量有时候被称为可寻址的值。即使变量由表达式临时生成，那么表达式也必须能接受& 取地址操作。

任何类型的指针的零值都是nil。如果p指向某个有效变量，那么p != nil 测试为真。指针之间也是
可以进行相等测试的，只有当它们指向同一个变量或全部是nil时才相等。

在Go语言中，返回函数中局部变量的地址也是安全的,
var p = f()
func f() *int {
    v := 1
    return &v
}
每次调用f函数都将返回不同的结果,(注：创建了不同的局部变量)

每次我们对一个变量取地址，或者复制指针，我们都是为原变量创建了新的别名

2.3.3. new函数
另一个创建变量的方法是调用用内建的new函数。表达式new(T)将创建一个T类型的匿名变量，初
始化为T类型的零值，然后返回变量地址，返回的指针类型为*T 。

当然也可能有特殊情况：如果两个类型都是空的，也就是说类型的大小是0，例如struct{}
和 [0]int , 有可能有相同的地址（依赖具体的语言实现）（译注：请谨慎使用大小为0的类型，因
为如果类型的大小为0的话，可能导致Go语言的自动垃圾回收器有不同的行为，具体请查
看runtime.SetFinalizer 函数相关文档）。

由于new只是一个预定义的函数，它并不是一个关键字，因此我们可以将new名字重新定义为别的
类型

2.3.4. 变量的生命周期
for t := 0.0; t < cycles*2*math.Pi; t += res {
x := math.Sin(t)
y := math.Sin(t*freq + phase)
img.SetColorIndex(
    size+int(x*size+0.5), size+int(y*size+0.5),
        blackIndex, // 最后插入的逗号不会导致编译错误，这是Go编译器的一个特性
    ) // 小括弧另起一行缩进，和大括弧的风格保存一致
}

从每个包级的变量和每个当前运行函数的每一个局部变量开
始，通过指针或引用的访问路径遍历，是否可以找到该变量。如果不存在这样的访问路径，那么说
明该变量是不可达的，也就是说它是否存在并不会影响程序后续的计算结果。
因为一个变量的有效周期只取决于是否可达，因此一个循环迭代内部的局部变量的生命周期可能超
出其局部作用域。同时，局部变量可能在函数返回之后依然存在。

编译器会自动选择在栈上还是在堆上分配局部变量的存储空间，但可能令人惊讶的是，这个选择并
不是由用var还是new声明变量的方式决定的。
var global *int
func f() {
    var x int
    x = 1
    global = &x
}
func g() {
    y := new(int)
    *y = 1
}

f函数里的x变量必须在堆上分配，因为它在函数退出后依然可以通过包一级的global变量找到，虽
然它是在函数内部定义的；用Go语言的术语说，这个x局部变量从函数f中逃逸了。相反，当g函数
返回时，变量*y 将是不可达的，也就是说可以马上被回收的。因此， *y 并没有从函数g中逃逸，编
译器可以选择在栈上分配*y 的存储空间（译注：也可以选择在堆上分配，然后由Go语言的GC回收
这个变量的内存空间），虽然这里用的是new方式。其实在任何时候，你并不需为了编写正确的代
码而要考虑变量的逃逸行为，要记住的是，逃逸的变量需要额外分配内存，同时对性能的优化可能
会产生细微的影响.

Go语言的自动垃圾收集器对编写正确的代码是一个巨大的帮助，但也并不是说你完全不用考虑内
存了。你虽然不需要显式地分配和释放内存，但是要编写高效的程序你依然需要了解变量的生命周
期。例如，如果将指向短生命周期对象的指针保存到具有长生命周期的对象中，特别是保存到全局
变量时，会阻止对短生命周期对象的垃圾回收（从而可能影响程序的性能）。

2.4. 赋值
2.4.1. 元组赋值
在赋值之前，赋值语句右边的所有表达式将会先进行求值，然后再统一更新左边对应变量的值,
x, y = y, x
a[i], a[j] = a[j], a[i]

计算两个整数值的的最大公约数（GCD）
func gcd(x, y int) int {
for y != 0 {
    x, y = y, x%y
}
    return x
}

计算斐波纳契数列（Fibonacci）的第N个数：
func fib(n int) int {
    x, y := 0, 1
    for i := 0; i < n; i++ {
        x, y = y, x+y
}
    return x
}

有些表达式会产生多个值，比如调用一个有多个返回值的函数。当这样一个函数调用出现在元组赋
值右边的表达式中时（译注：右边不能再有其它表达式），左边变量的数目必须和右边一致。
f, err = os.Open("foo.txt") // function call returns two values

2.4.2. 可赋值性
medals := []string{"gold", "silver", "bronze"}
隐式地对slice的每个元素进行赋值操作，类似这样写的行为：
medals[0] = "gold"
medals[1] = "silver"
medals[2] = "bronze"

不管是隐式还是显式地赋值，在赋值语句左边的变量和右边最终的求到的值必须有相同的数据类
型。更直白地说，只有右边的值对于左边的变量是可赋值的，赋值语句才是允许的。

nil可以赋值给任何指针或引用类型的变量

对于两个值是否可以用== 或!= 进行相等比较的能力也和可赋值能力有关系：对于任何类型的值的
相等比较，第二个值必须是对第一个值类型对应的变量是可赋值的

2.5. 类型
一个类型声明语句创建了一个新的类型名称，和现有类型具有相同的底层结构。新命名的类型提供
了一个方法，用来分隔不同概念的类型，这样即使它们底层类型相同也是不兼容的。
type 类型名字 底层类型
类型声明语句一般出现在包一级，因此如果新创建的类型名字的首字符大写，则在外部包也可以使
用。

type Celsius float64 // 摄氏温度
type Fahrenheit float64 // 华氏温度
声明了两种类型：Celsius和Fahrenheit分别对应不同的温度单位。它们虽然有着相同
的底层类型float64，但是它们是不同的数据类型，因此它们不可以被相互比较或混在一个表达式运
算。

底层数据类型决定了内部结构和表达方式，也决定是否可以像底层类型一样对内置运算符的支持。
这意味着，Celsius和Fahrenheit类型的算术运算行为和底层的float64类型是一样的

对于每一个类型T，都有一个对应的类型转换操作T(x)，用于将x转为T类型（译注：如果T是指针类
型，可能会需要用小括弧包装T，比如(*int)(0) ）。只有当两个类型的底层基础类型相同时，才允
许这种转型操作，或者是两者都是指向相同底层结构的指针类型，这些转换只改变类型而不会影响
值本身

在任何情况下，运行时不会发生转换失败的错误（译注: 错误只会发生在编译阶段）。

比较运算符== 和< 也可以用来比较一个命名类型的变量和另一个有相同类型的变量，或有着相同底
层类型的未命名类型的值之间做比较。但是如果两个值有着不同的类型，则不能直接进行比较

命名类型还可以为该类型的值定义新的行为。这些行为表示为一组关联到该类型的函数集合，我们
称为类型的方法集

2.6. 包和文件
包的源文件在一个目录中，该目录以包的导入路径结束
 The source code for a packageresides in one or more .go files, usually in a directory
whose name ends with the import path;for instance, the files of the gopl.io/ch1/helloworld
 package are stored in directory$GOPATH/src/gopl.io/ch1/helloworld.

 包还可以让我们通过控制哪些名字是外部可见的来隐藏内部实现信息。在Go语言中，一个简单的
规则是：如果一个名字是大写字母开头的，那么该名字是导出的（译注：因为汉字不区分大小写，
因此汉字开头的名字是没有导出的）

通常，包只有一个注释，在源文件的声明前；如果有多个注释，应放在一个文件中，一般叫做doc.go

2.6.1. 导入包
在Go语言程序中，每个包都是有一个全局唯一的导入路径;
除了包的导入路径，每个包还有一个包名，包名一般是短小的名字（并不要求包名是唯一的），包
名在包的声明处指定。按照惯例，一个包的名字和包的导入路径的最后一个字段相同，例如
gopl.io/ch2/tempconv包的名字一般是tempconv;

如果导入了一个包，但是又没有使用该包将被当作一个编译错误处理;

不过有更好的解决方案，我们可以使用golang.org/x/tools/cmd/goimports导入工具，它可以根据需
要自动添加或删除导入的包；许多编辑器都可以集成goimports工具，然后在保存文件的时候自动
运行。类似的还有gofmt工具，可以用来格式化Go源文件。

2.6.2. 包的初始化
首先解决有依赖的变量，再按照声明顺序初始化；
var a = b + c // a 第三个初始化, 为 3
var b = f() // b 第二个初始化, 为 2, 通过调用 f (依赖c)
var c = 1 // c 第一个初始化, 为 1
func f() int { return c + 1 }

如果包中含有多个.go源文件，它们将按照发给编译器的顺序进行初始化；Go语言的构建工具首先
会将.go文件根据文件名排序，然后依次调用编译器编译


对于在包级别声明的变量，如果有初始化表达式则用表达式初始化，还有一些没有初始化表达式
的，例如某些表格数据初始化并不是一个简单的赋值过程。在这种情况下，我们可以用一个特殊的
init初始化函数来简化初始化工作。每个文件都可以包含多个init初始化函数
func init() { /* ... */ }
这样的init初始化函数除了不能被调用或引用外，其他行为和普通函数类似。在每个文件中的init初
始化函数，在程序开始执行时按照它们声明的顺序被自动调用。

包按照依赖优先的导入顺序进行初始化，main包最后被初始化

[PopCount函数??]

2.7. 作用域
一个声明语句将程序中的实体和一个名字关联，比如一个函数或一个变量。声明语句的作用域是指
源代码中可以有效使用这个名字的范围。

不要将作用域和生命周期混为一谈。声明语句的作用域对应的是一个源代码的文本区域；它是一个
编译时的属性。一个变量的生命周期是指程序运行时变量存在的有效时间段，在此时间区域内它可
以被程序的其他部分引用；是一个运行时的概念。

<英文P46>
语法块：花括号包围的声明语句序列；包含整个源代码的
词法块/字典块，被称作全局块

控制流标号，就是break、continue或goto语句后面跟着的那种标号，则是函数级的作用域

声明语句对应的词法域决定了作用域范围的大小。对于内置的类型、函数和常量，比如int、len和
true等是在全局作用域的，因此可以在整个程序中直接使用。任何在在函数外部（也就是包级语法
域）声明的名字可以在同一个包的任何源文件中访问的。对于导入的包，例如tempconv导入的fmt
包，则是对应源文件级的作用域，因此只能在当前的文件中访问导入的fmt包，当前包的其它源文
件无法访问在当前源文件导入的包。还有许多声明语句，比如tempconv.CToF函数中的变量c，则
是局部作用域的，它只能在函数内部（甚至只能是局部的某些部分）访问

if x := f(); x == 0 {
    fmt.Println(x)
} else if y := g(x); x == y {
    fmt.Println(x, y)
} else {
    fmt.Println(x, y)
}
fmt.Println(x, y) // compile error: x and y are not visible here
第二个if语句嵌套在第一个内部，因此第一个if语句条件初始化词法域声明的变量在第二个if中也可
以访问。switch语句的每个分支也有类似的词法域规则：条件部分为一个隐式词法域，然后每个是
每个分支的词法域。

在包级别，声明的顺序并不会影响作用域范围，因此一个先声明的可以引用它自身或者是引用后面
的一个声明，这可以让我们定义一些相互嵌套或递归的类型或函数。但是如果一个变量或常量递归
引用了自身，则会产生编译错误

var cwd string
func init() {
    cwd, err := os.Getwd() // compile error: unused: cwd
    if err != nil {
        log.Fatalf("os.Getwd failed: %v", err)
}
}
虽然cwd在外部已经声明过，但是:= 语句还是将cwd和err重新声明为新的局部变量。因为内部声明
的cwd将屏蔽外部的声明，因此上面的代码并不会正确更新包级声明的cwd变量

有许多方式可以避免出现类似潜在的问题。最直接的方法是通过单独声明err变量，来避免使用:=
的简短声明方式：
var cwd string
func init() {
    var err error
    cwd, err = os.Getwd()
    if err != nil {
        log.Fatalf("os.Getwd failed: %v", err)
}
}

