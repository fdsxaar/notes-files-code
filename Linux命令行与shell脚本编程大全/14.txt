第14章 处理用户输入

bash shell会将一些称为位置参数（positional parameter）的特殊变量分配给输入到命令行中的
所有参数。这也包括shell所执行的脚本名称。位置参数变量是标准的数字：$0是程序名，$1是第
一个参数，$2是第二个参数，依次类推，直到第九个参数$9。
如果需要输入更多的命令行参数，则每个参数都必须用空格分开。
要在参数值中包含空格，必须要用引号（单引号或双引号均可）。
在第9个变量之后，你必须在变量数字周围加上花括号，比如${10}
可以用$0参数获取shell在命令行启动的脚本名;
basename命令会返回不包含路径的脚本名。

通过链接（参见第3章）创建（multem）。
ln -s test6.sh multem

在使用参数前一定要检查其中是否存在数据。
if [ -n "$1" ]
使用了-n测试来检查命令行参数$1中是否有数据

特殊变量$#含有脚本运行时携带的命令行参数的个数,不包括脚本名参数;
不能在花括号内使用美元符。必须将美元符换成感叹
号
echo The last parameter was ${$#}

$*变量会将命令行上提供的所有参数当作一个单词保存。这个单词包含了命令行中出现的每
一个参数值。基本上$*变量会将这些参数视为一个整体，而不是多个个体。
另一方面，$@变量会将命令行上提供的所有参数当作同一字符串中的多个独立的单词。这样
你就能够遍历所有的参数值，得到每个参数。这通常通过for命令完成。

在使用shift命令时，默认情况下它会将每个参数变量向左移动一个位置。所以，变量$3
的值会移到$2中，变量$2的值会移到$1中，而变量$1的值则会被删除（注意，变量$0的值，也
就是程序名，不会改变）。

14.4 处理选项 应该使用getopt/getopts函数
在提取每个单独参数时，用case语句（参见第12章）来判断某个参数是否为选项。

。shell会用双破折线来表明选项列表结束
p298特殊的例子，

getopt optstring parameters
首先，在optstring中列出你要在脚本中用到的每个命令行选项字母。然后，在每个需要参
数值的选项字母后加一个冒号。getopt命令会基于你定义的optstring解析提供的参数。
如果想忽略错误消息，可以在命令后加-q选项。
get -q a:b -a aa -b -c 

set命令的选项之一是双破折线（--），它会将命令行参数替换成set命令的命令行值。
然后，该方法会将原始脚本的命令行参数传给getopt命令，之后再将getopt命令的输出传
给set命令，用getopt格式化后的命令行参数来替换原始的命令行参数，看起来如下所示。
set -- $(getopt -q ab:c "$@")
#注：set重新排列了参数,键见脚本getopt.sh 
getopt hy ya -a -b bb
>>> -a -b  hy ya 
getopt命令并不擅长处理带空格和引号的参数值。它会将空格当作参数分隔符，而不是根
据双引号将二者当作一个参数。

getopts optstring variable
optstring值类似于getopt命令中的那个。有效的选项字母都会列在optstring中，如果
选项字母要求有个参数值，就加一个冒号。要去掉错误消息的话，可以在optstring之前加一个
冒号。getopts命令将当前参数保存在命令行中定义的variable中。
getopts命令会用到两个环境变量。如果选项需要跟一个参数值，OPTARG环境变量就会保
存这个值。OPTIND环境变量保存了参数列表中getopts正在处理的参数位置。这样你就能在处
理完选项之后继续处理其他命令行参数了。
可以在参数值中包含空格。
getopts还能够将命令行上找到的所有未定义的选项统一输出成问号。

#注 有待商榷,OPTIND的值似乎为下一个要处理的参数/选项的位置，另一个需要注意的是，
#getopts必须先列出选项，再列出参数值，不能像getopt一样，可以乱序列出选项以及参数值
getopts命令知道何时停止处理选项，并将参数留给你处理。在getopts处理每个选项时，
它会将OPTIND环境变量值增一

将选项标准化
表14-1 常用的Linux命令选项
选项 描 述
-a 显示所有对象
-c 生成一个计数
-d 指定一个目录
-e 扩展一个对象
-f 指定读入数据的文件
-h 显示命令的帮助信息
-i 忽略文本大小写
-l 产生输出的长格式版本
-n 使用非交互模式（批处理）
-o 将所有输出重定向到的指定的输出文件
-q 以安静模式运行
-r 递归地处理目录和文件
-s 以安静模式运行
-v 生成详细输出
-x 排除某个对象
-y 对所有问题回答yes

14.6 获得用户输入
read命令从标准输入（键盘）或另一个文件描述符中接受输入。在收到输入后，read命令
会将数据放进一个变量；
echo -n "Enter name:"
read name 
注意，生成提示的echo命令使用了-n选项。该选项不会在字符串末尾输出换行
符，允许脚本用户紧跟其后输入数据，而不是下一行。这让脚本看起来更像表单。
实际上，read命令包含了-p选项，允许你直接在read命令行指定提示符。
read -p "Please enter your age: " age

read命令会将提示符后输入的所有数据分配给单个变量，要么你就指定多个变量。输入的每个
数据值都会分配给变量列表中的下一个变量。如果变量数量不够，剩下的数据就全部分配给最后
一个变量。
read -p "Enter: " v1 v2 
也可以在read命令行中不指定变量。如果是这样，read命令会将它收到的任何数据都放进
特殊环境变量REPLY中。
read 
echo $REPLY 

如果不管是否有数据
输入，脚本都必须继续执行，你可以用-t选项来指定一个计时器。-t选项指定了read命令等待
输入的秒数。当计时器过期后，read命令会返回一个非零退出状态码。
read -t 5 -p "Enter: " #注：能作if语句的判断语句

#注：在脚本中能通用 -nl选项，但是不能用在命令行中，
将-n选项和值1一起使用，告诉read命令在接受单个字符后退出。只要按下单个字符
回答后，read命令就会接受输入并将它传给变量，无需按回车键。

-s选项可以避免在read命令中输入的数据出现在显示器上（实际上，数据会被显示，只是
read命令会将文本颜色设成跟背景色一样）
echo $REPLY #显示出来 

最后，也可以用read命令来读取Linux系统上文件里保存的数据。每次调用read命令，它都
会从文件中读取一行文本。当文件中再没有内容时，read命令会退出并返回非零退出状态码。
其中最难的部分是将文件中的数据传给read命令。最常见的方法是对文件使用cat命令，将
结果通过管道直接传给含有read命令的while命令。


