第11 章 构建基本脚本
11/test1文本

shell可以让你将多个命令串起来，一次执行完成。如果要两个命令一起运行，可以
把它们放在同一行中，彼此间用分号隔开，只要不超过最大命令行字符数255就行
$ date ; who

11.2 创建shell 脚本文件
在创建shell脚本文件时，必须在文件的第一行指定要使用的shell。其格式为：
#!/bin/bash
在通常的shell脚本中，井号（#）用作注释行。shell并不会处理shell脚本中的注释行。然而，
shell脚本文件的第一行是个例外，#后面的惊叹号会告诉shell用哪个shell来运行脚本

$ echo $PATH 查看变量 
$ ./test1  执行命令
$ ls -l test1 显示权限
$ chmod u+x test1 更改权限

echo命令可用单引号或双引号来划定文本字符串。如果在字符串中用到了它们，你需要在
文本中使用其中一种引号，而用另外一种来将字符串划定起来。
$ echo "This is a test to see if you're paying attention"
This is a test to see if you're paying attention
$ echo 'Rich says "scripting is easy".'
Rich says "scripting is easy".

但如果想把文本字符串和命令输出显示在同一行中，该怎么办呢？可以用echo语句
的-n参数。只要将第一个echo语句改成这样就行：
echo -n "The time and date are: "

shell维护着一组环境变量，用来记录特定的系统信息，可以用
set命令来显示一份完整的当前环境变量列表

在脚本中，你可以在环境变量名称之前加上美元符（$）来使用这些环境变量
$ cat test2
#!/bin/bash
# display user information from the system.
echo "User info for userid: $USER"
echo UID: $UID
echo HOME: $HOME

在第一个字符串中可
以将$USER系统变量放置到双引号中，而shell依然能够知道我们的意图

$ echo "The cost of the item is $15"
The cost of the item is 5
只要脚本在引号中出现美元符，它就会以为你在引用一个变量。在
这个例子中，脚本会尝试显示变量$1（但并未定义），再显示数字5。要显示美元符，你必须在它
前面放置一个反斜线。
$ echo "The cost of the item is \$15"
The cost of the item is $15

11.4.2 用户变量
除了环境变量，shell脚本还允许在脚本中定义和使用自己的变量;

内联输入重定向符号是远小于号（<<）。除了这个符号，你必须指定一个文本标记来划分输
入数据的开始和结尾。任何字符串都可作为文本标记，但在数据的开始和结尾文本标记必须一致。
command << marker
data
marker

$ wc << EOF
> 1
> 2
> 3
> EOF


expr 命令

$ expr 5 * 2
expr: syntax error
$
要解决这个问题，对于那些容易被shell错误解释的字符，在它们传入expr命令之前，需要使
用shell的转义字符（反斜线）将其标出来。

var3=$(expr $var2 / $var1)
要将一个数学算式的结果赋给一个变量，需要使用命令替换来获取expr命令的输出：

bash shell为了保持跟Bourne shell的兼容而包含了expr命令，但它同样也提供了一种更简单
的方法来执行数学表达式。在bash中，在将一个数学运算结果赋给某个变量时，可以用美元符和
方括号（$[ operation ]）将数学表达式围起来。
$ var1=$[1 + 5]

bash shell数学运算符只支持整数运算。若要进行任何实际的数学计算，这是一个巨大的限制。
说明 z shell（zsh）提供了完整的浮点数算术操作

shell中运行的每个命令都使用退出状态码（exit status）告诉shell它已经运行完毕。退出状态
码是一个0～255的整数值，在命令结束运行时由命令传给shell。可以捕获这个值并在脚本中使用。

Linux提供了一个专门的变量$?来保存上个已执行命令的退出状态码。对于需要进行检查的
命令，必须在其运行完毕后立刻查看或使用$?变量。它的值会变成由shell所执行的最后一条命令
的退出状态码。
$ echo $?

第12章 使用结构化命令
if command
    then
commands
fi 
bash shell的if语句会运行if后面的那个命令。如果该命令的退出状态码（参见第11章）是0
（该命令成功运行），位于then部分的命令就会被执行。如果该命令的退出状态码是其他值， then
部分的命令就不会被执行，bash shell会继续执行脚本中的下一个命令。fi语句用来表示if-then
语句到此结束。

if command1
then
   commands
elif command2
then
   more commands
fi

if command1
then
   commands
elif command2
then 
   conmmands
else 
   commands 
fi 
在elif语句中，紧跟其后的else语句属于elif代码块 

if command1
then
    command set 1
elif command2
then
    command set 2
elif command3
then
    command set 3
elif command4
then
    command set 4
fi

test命令提供了在if-then语句中测试不同条件的途径。如果test命令中列出的条件成立，
test命令就会退出并返回退出状态码0
test condition

if test condition
then
    commands
fi
如果不写test命令的condition部分，它会以非零的退出状态码退出，并执行else语句块。

bash shell提供了另一种条件测试方法，无需在if-then语句中声明test命令。
if [ condition ]
then
   commands
fi
注意，第一个方括号之后和第二个方括号之前必须加上一个空格;
bash shell只能处理整数,不能在test命令中使用浮点值。


字符串比较顺序
 大于号和小于号必须转义，否则shell会把它们当作重定向符号，把字符串值当作文件
名；需要正确转义大于号；
 大于和小于顺序和sort命令所采用的不同。

在比较测试中，大写字母被认为是小于小写字母的。但sort命令恰好相反。当你将同样的
字符串放进文件中并用sort命令排序时，小写字母会先出现。这是由各个命令使用的排序技术
不同造成的。
比较测试中使用的是标准的ASCII顺序，根据每个字符的ASCII数值来决定排序结果。sort
命令使用的是系统的本地化语言设置中定义的排序顺序。对于英语，本地化设置指定了在排序顺
序中小写字母出现在大写字母前。

if [ -z $val3 ]
判断val3变量是否长度为0。这个变量并未在shell脚本中定义过，所以它的字符串长度仍然
为0，尽管它未被定义过。

在尝试从文件中读取数据之前，最好先测试一下文件是否可读。
if [ -f file ]
then 
#
fi 

应该用-s比较来检查文件是否为空，尤其是在不想删除非空文件的时候。要留心的是，当
-s比较成功时，说明文件中有数据。

-G比较会检查文件的默认组，如果它匹配了用户的默认组，则测试成功

检查文件日期
在编写软件安装脚本时非常有用,-nt比较会判定一个文件是否比另一个文件新,
-ot比较会判定一个文件是否比另一个文件旧,-ot比较会判定一个文件是否比另一个文件旧
,比较不会先检查文件是否存在,在你尝试使用-nt或-ot比较文件之前，必须先确认文件是存在的。

 [ condition1 ] && [ condition2 ]
 [ condition1 ] || [ condition2 ]

bash shell提供了两项可在if-then语句中使用的高级特性：
 用于数学表达式的双括号
 用于高级字符串处理功能的双方括号

(( expression ))
expression可以是任意的数学赋值或比较表达式。除了test命令使用的标准数学运算符，
表12-4列出了双括号命令中会用到的其他运算符。

if (( $val1 ** 2 > 90 ))
注意，不需要将双括号中表达式里的大于号转义。这是双括号命令提供的另一个高级特性。
      #!/bin/bash
      2 #数字比较不再需要 -gt -ge 啦
      3 if ((3>1))
      4 then
      5 echo "大于 "
      6 else
      7     echo "3<=4"
      8 fi



双方括号命令提供了针对字符串比较的高级特性。双方括号命令的格式如下：
[[ expression ]]
提供了test命令未提供的另一个特性——模式匹配（pattern matching）
在模式匹配中，可以定义一个正则表达式来匹配字符串值

case 命令
case variable/value in
pattern1 | pattern2) commands1;;
pattern3) commands2;;
*) default commands;;
esac


更多的结构化命令

for var in list
do
   commands
done

说明 只要你愿意，也可以将do语句和for语句放在同一行，但必须用分号将其同列表中的值分
开：for var in list; do
for循环假定每个值都是用空格分割的；for命令用空格来划分列表中的每个值。如果在单独的数据值中有
空格，就必须用双引号将这些值圈起来。

单引号问题：
 使用转义字符（反斜线）来将单引号转义；
 使用双引号来定义用到单引号的值。

叫作内部字段分隔符（internal field separator）。
IFS环境变量定义了bash shell用作字段分隔符的一系列字符。默认情况下，bash shell会将下列字
符当作字段分隔符：
 空格
 制表符
 换行符
要解决这个问题，可以在shell脚本中临时更改IFS环境变量的值来限制被bash shell当作字段
分隔符的字符。例如，如果你想修改IFS的值，使其只能识别换行符，那就必须这么做：
IFS=$'\n'
注:换行符的指定方式  $'\n', 有$符号
IFS.OLD=$IFS
IFS=$'\n'
<在代码中使用新的IFS值>
IFS=$IFS.OLD
这就保证了在脚本的后续操作中使用的是IFS的默认

最后，可以用for命令来自动遍历目录中的文件。进行此操作时，必须在文件名或路径名中
使用通配符。它会强制shell使用文件扩展匹配。文件扩展匹配是生成匹配指定通配符的文件名或
路径名的过程。
if [ -f '$file' ]
在Linux中，目录名和文件名中包含空格当然是合法的，应该将$file变
量用双引号圈起来。如果不这么做，遇到含有空格的目录名或文件名时就会有错误产生。

13.2 C 语言风格的for 命令
bash中C语言风格的for循环的基本格式。
for (( variable assignment ; condition ; iteration process ))
for (( a = 1; a < 10; a++ ))
注意，有些部分并没有遵循bash shell标准的for命令：
 变量赋值可以有空格；
 条件中的变量不以美元符开头；
 迭代过程的算式未用expr命令格式。

while test command
do
   other commands
done
while命令中定义的test command和if-then语句中的格式一模一样。可
以使用任何普通的bash shell命令，或者用test命令进行条件测试，比如测试变量值。
while命令允许你在while语句行定义多个测试命令。只有最后一个测试命令的退出状态码
会被用来决定什么时候结束循环,每个测试命令都出现在单独的一行上。

until命令要求你指定一个通常返回非零退
出状态码的测试命令。只有测试命令的退出状态码不为0，bash shell才会执行循环中列出的命令。
一旦测试命令返回了退出状态码0，循环就结束了。
#用退出状态码似乎不对，util应该是条件测试
until test commands
do
    other commands
done

通常必须遍历存储在文件中的数据
 使用嵌套循环
 修改IFS环境变量
IFS.OLD=$IFS
IFS=$'\n'
for (())
    IFS=:
    for(())

在shell执行break命令时，它会尝试跳出当前正在执行的循环。

有时你在内部循环，但需要停止外部循环。break命令接受单个命令行参数值：
break n
其中n指定了要跳出的循环层级。默认情况下，n为1，表明跳出的是当前的循环。如果你将
n设为2，break命令就会停止下一级的外部循环

continue命令可以提前中止某次循环中的命令，但并不会完全终止整个循环;
跳过此次循环中剩余的命令，但整个循环还会继续。

可以对循环的输出使用管道或进行重定向。这可以通过在done命令
之后添加一个处理命令来实现。

while IFS=’,’ read –r userid name
read命令会自动读取.csv文本文件的下一行内容，所以不需要专门再写一个循环来处理。当
read命令返回FALSE时（也就是读取完整个文件时），while命令就会退出。
要想把数据从文件中送入while命令，只需在while命令尾部使用一个重定向符就可以了。

第14章 处理用户输入

bash shell会将一些称为位置参数（positional parameter）的特殊变量分配给输入到命令行中的
所有参数。这也包括shell所执行的脚本名称。位置参数变量是标准的数字：$0是程序名，$1是第
一个参数，$2是第二个参数，依次类推，直到第九个参数$9。
如果需要输入更多的命令行参数，则每个参数都必须用空格分开。
要在参数值中包含空格，必须要用引号（单引号或双引号均可）。
在第9个变量之后，你必须在变量数字周围加上花括号，比如${10}
可以用$0参数获取shell在命令行启动的脚本名;
basename命令会返回不包含路径的脚本名。

通过链接（参见第3章）创建（multem）。
ln -s test6.sh multem

在使用参数前一定要检查其中是否存在数据。
if [ -n "$1" ]
使用了-n测试来检查命令行参数$1中是否有数据

特殊变量$#含有脚本运行时携带的命令行参数的个数,不包括脚本名参数;
不能在花括号内使用美元符。必须将美元符换成感叹号
echo The last parameter was ${$#}

$*变量会将命令行上提供的所有参数当作一个单词保存。这个单词包含了命令行中出现的每
一个参数值。基本上$*变量会将这些参数视为一个整体，而不是多个个体。
另一方面，$@变量会将命令行上提供的所有参数当作同一字符串中的多个独立的单词。这样
你就能够遍历所有的参数值，得到每个参数。这通常通过for命令完成。

在使用shift命令时，默认情况下它会将每个参数变量向左移动一个位置。所以，变量$3
的值会移到$2中，变量$2的值会移到$1中，而变量$1的值则会被删除（注意，变量$0的值，也
就是程序名，不会改变）。

14.4 处理选项 应该使用getopt/getopts函数
在提取每个单独参数时，用case语句（参见第12章）来判断某个参数是否为选项。

。shell会用双破折线来表明选项列表结束
p298特殊的例子，

getopt optstring parameters
首先，在optstring中列出你要在脚本中用到的每个命令行选项字母。然后，在每个需要参
数值的选项字母后加一个冒号。getopt命令会基于你定义的optstring解析提供的参数。
如果想忽略错误消息，可以在命令后加-q选项。
get -q a:b -a aa -b -c 

set命令的选项之一是双破折线（--），它会将命令行参数替换成set命令的命令行值。
然后，该方法会将原始脚本的命令行参数传给getopt命令，之后再将getopt命令的输出传
给set命令，用getopt格式化后的命令行参数来替换原始的命令行参数，看起来如下所示。
set -- $(getopt -q ab:c "$@")
#注：set重新排列了参数,键见脚本getopt.sh 
getopt hy ya -a -b bb
>>> -a -b  hy ya 
getopt命令并不擅长处理带空格和引号的参数值。它会将空格当作参数分隔符，而不是根
据双引号将二者当作一个参数。

getopts optstring variable
optstring值类似于getopt命令中的那个。有效的选项字母都会列在optstring中，如果
选项字母要求有个参数值，就加一个冒号。要去掉错误消息的话，可以在optstring之前加一个
冒号。getopts命令将当前参数保存在命令行中定义的variable中。
getopts命令会用到两个环境变量。如果选项需要跟一个参数值，OPTARG环境变量就会保
存这个值。OPTIND环境变量保存了参数列表中getopts正在处理的参数位置。这样你就能在处
理完选项之后继续处理其他命令行参数了。
可以在参数值中包含空格。
getopts还能够将命令行上找到的所有未定义的选项统一输出成问号。

#注 有待商榷,OPTIND的值似乎为下一个要处理的参数/选项的位置，另一个需要注意的是，
#getopts必须先列出选项，再列出参数值，不能像getopt一样，可以乱序列出选项以及参数值
getopts命令知道何时停止处理选项，并将参数留给你处理。在getopts处理每个选项时，
它会将OPTIND环境变量值增一

将选项标准化
表14-1 常用的Linux命令选项
选项 描 述
-a 显示所有对象
-c 生成一个计数
-d 指定一个目录
-e 扩展一个对象
-f 指定读入数据的文件
-h 显示命令的帮助信息
-i 忽略文本大小写
-l 产生输出的长格式版本
-n 使用非交互模式（批处理）
-o 将所有输出重定向到的指定的输出文件
-q 以安静模式运行
-r 递归地处理目录和文件
-s 以安静模式运行
-v 生成详细输出
-x 排除某个对象
-y 对所有问题回答yes

14.6 获得用户输入
read命令从标准输入（键盘）或另一个文件描述符中接受输入。在收到输入后，read命令
会将数据放进一个变量；
echo -n "Enter name:"
read name 
注意，生成提示的echo命令使用了-n选项。该选项不会在字符串末尾输出换行
符，允许脚本用户紧跟其后输入数据，而不是下一行。这让脚本看起来更像表单。
实际上，read命令包含了-p选项，允许你直接在read命令行指定提示符。
read -p "Please enter your age: " age

read命令会将提示符后输入的所有数据分配给单个变量，要么你就指定多个变量。输入的每个
数据值都会分配给变量列表中的下一个变量。如果变量数量不够，剩下的数据就全部分配给最后
一个变量。
read -p "Enter: " v1 v2 
也可以在read命令行中不指定变量。如果是这样，read命令会将它收到的任何数据都放进
特殊环境变量REPLY中。
read 
echo $REPLY 

如果不管是否有数据
输入，脚本都必须继续执行，你可以用-t选项来指定一个计时器。-t选项指定了read命令等待
输入的秒数。当计时器过期后，read命令会返回一个非零退出状态码。
read -t 5 -p "Enter: " #注：能作if语句的判断语句

#注：在脚本中能通用 -nl选项，但是不能用在命令行中，
将-n选项和值1一起使用，告诉read命令在接受单个字符后退出。只要按下单个字符
回答后，read命令就会接受输入并将它传给变量，无需按回车键。

-s选项可以避免在read命令中输入的数据出现在显示器上（实际上，数据会被显示，只是
read命令会将文本颜色设成跟背景色一样）
echo $REPLY #显示出来 

最后，也可以用read命令来读取Linux系统上文件里保存的数据。每次调用read命令，它都
会从文件中读取一行文本。当文件中再没有内容时，read命令会退出并返回非零退出状态码。
其中最难的部分是将文件中的数据传给read命令。最常见的方法是对文件使用cat命令，将
结果通过管道直接传给含有read命令的while命令。


第15 章 呈现数据

每个进程一次最多可以有九个文件描述符

STDIN文件描述符代表shell的标准输入。对终端界面来说，标准输入是键盘

STDOUT文件描述符代表shell的标准输出。在终端界面上，标准输出就是终端显示器

STDERR文件描述符被设成2。可以选择只重定向错误消息，将该文
件描述符值放在重定向符号前。该值必须紧紧地放在重定向符号前，否则不会工作。
ls -al file 2> errlog

如果想重定向错误和正常输出，必须用两个重定向符号。需要在符号前面放上待重定向数据
所对应的文件描述符，然后指向用于保存数据的输出文件。
$ ls -al test test2 test3 badtest 2> test6 1> test7

另外，如果愿意，也可以将STDERR和STDOUT的输出重定向到同一个输出文件。为此bash shell
提供了特殊的重定向符号&>。
$ ls -al test test2 test3 badtest &> test7

15.2.1 临时重定向
如果有意在脚本中生成错误消息，可以将单独的一行输出重定向到STDERR。你所需要做的
是使用输出重定向符来将输出信息重定向到STDERR文件描述符。在重定向到文件描述符时，你
必须在文件描述符数字之前加一个&：
echo "This is an error message" >&2
这行会在脚本的STDERR文件描述符所指向的位置显示文本，而不是通常的STDOUT;

默认情况下，Linux会将STDERR导向STDOUT。但是，如果你在运行脚本时重定向了
STDERR，脚本中所有导向STDERR的文本都会被重定向。

15.2.2 永久重定向
用exec命令告诉shell在脚本执行期间重定向某个
# redirecting all output to a file
exec 1>testout
exec命令会启动一个新shell并将STDOUT文件描述符重定向到文件

exec命令允许你将STDIN重定向到Linux系统上的文件中：
exec 0< testfile
while read line
do 
#
done
这是在脚本中从待处理的文件中读取数据的绝妙办法。Linux系统管理员的一项日常任务就
是从日志文件中读取数据并处理。这是完成该任务最简单的办法。

15.4 创建自己的重定向
exec 3>test13out
echo "and this should be stored in the file" >&3
也可以不用创建新文件，而是使用exec命令来将输出追加到现有文件中。
exec 3>>test13out

恢复已重定向的文件描述符
exec 3>&1
exec 1>test14out
echo "xxx"
exec 1>&3

15.4.3 创建输入文件描述符
在重定向到文件之前，先将STDIN文件描述符保存到另外一个文件描述符，然后在读取完文件之后再将STDIN恢复到它
原来的位置。
exec 6<&0
exec 0< testfile
while read line
do
#xxx
done
exec 0<&6

文件描述符6用来保存STDIN的位置

15.4.4 创建读写文件描述符
#糟糕的实践，会覆盖数据
由于你是对同一个文件进行数据读写，shell会维护一个
内部指针，指明在文件中的当前位置。任何读或写都会从文件指针上次的位置开始
exec 3<> testfile
read line <&3

15.4.5 关闭文件描述符
如果你创建了新的输入或输出文件描述符，shell会在脚本退出时自动关闭它们；
要关闭文件描述符，将它重定向到特殊符号&-。
exec 3>&-

在关闭文件描述符时还要注意另一件事。如果随后你在脚本中打开了同一个输出文件，shell
会用一个新文件来替换已有文件。这意味着如果你输出数据，它就会覆盖已有文件；

15.5 列出打开的文件描述符
lsof命令会列出整个Linux系统打开的所有文件描述符；
有大量的命令行选项和参数可以用来帮助过滤lsof的输出。最常用的有-p和-d，前者允许
指定进程ID（PID），后者允许指定要显示的文件描述符编号。
要想知道进程的当前PID，可以用特殊环境变量$$（shell会将它设为当前PID）。-a选项用来
对其他两个选项的结果执行布尔AND运算
$lsof -a -p $$ -d 0,1,2 

表15-2 lsof的默认输出
列 描 述
COMMAND 正在运行的命令名的前9个字符
PID 进程的PID
USER 进程属主的登录名
FD 文件描述符号以及访问类型（r代表读，w代表写，u代表读写）
TYPE 文件的类型（CHR代表字符型，BLK代表块型，DIR代表目录，REG代表常规文件）
DEVICE 设备的设备号（主设备号和从设备号）
SIZE 如果有的话，表示文件的大小
NODE 本地文件的节点号
NAME 文件名
与STDIN、STDOUT和STDERR关联的文件类型是字符型。因为STDIN、STDOUT和STDERR文
件描述符都指向终端，所以输出文件的名称就是终端的设备名。所有3种标准文件都支持读和写

15.6 阻止命令输出
在Linux系统上null文件的标准位置是/dev/null。你重定向到该位置的任何数据都会被丢掉;
也可以在输入重定向中将/dev/null作为输入文件。由于/dev/null文件不含有任何内容，程序员
通常用它来快速清除现有文件中的数据，而不用先删除文件再重新创建。
cat /dev/null > testfile

15.7 创建临时文件
Linux使用/tmp目录来存放不需要永久保留的
文件。大多数Linux发行版配置了系统在启动时自动删除/tmp目录的所有文件。
系统上的任何用户账户都有权限在读写/tmp目录中的文件。这个特性为你提供了一种创建临
时文件的简单方法，而且还不用操心清理工作。mktemp命令可以在/tmp目录中创建一个唯一的临时
文件。shell会创建这个文件，但不用默认的umask值（参见第7章）。它会将文件的读和写权限分
配给文件的属主，并将你设成文件的属主;

要用mktemp命令在本地目录中创建一
个临时文件，你只要指定一个文件名模板就行了。模板可以包含任意文本文件名，在文件名末尾
加上6个X就行了。
$ mktemp testing.XXXXXX
mktemp命令会用6个字符码替换这6个X，从而保证文件名在目录中是唯一的
在/tmp 目录创建临时文件
-t选项会强制mktemp命令来在系统的临时目录来创建该文件。在用这个特性时，mktemp命
令会返回用来创建临时文件的全路径，而不是只有文件名。

$ mktemp -t test.XXXXXX
-d选项告诉mktemp命令来创建一个临时目录而不是临时文件

#指定文件名的话在当前目录创建目录，否则在/tmp目录中创建目录
$mktemp -d dir.XXXXXX
tempfile=$(mktemp test19.XXXXXX)#用完再删除

15.8 记录消息
tee命令相当于管道的一个T型接头。它将从STDIN过来的数据同时发往两处。一处是
STDOUT，另一处是tee命令行所指定的文件名：
tee filename
由于tee会重定向来自STDIN的数据，你可以用它配合管道命令来重定向命令输出。
默认情况下，tee命令会在每次使用时覆盖输出文件内容。
将数据追加到文件中，必须用-a选项。

$cat test23
#!/bin/bash
# read file and create INSERT statements for MySQL
outfile='members.sql'
IFS=','
while read lname fname address city state zip
do
cat >> $outfile << EOF
INSERT INTO members (lname,fname,address,city,state,zip) VALUES
('$lname', '$fname', '$address', '$city', '$state', '$zip');
EOF
done < ${1}

#done < $1 也对，见param.sh
done < ${1}
当运行程序test23时，$1代表第一个命令行参数。它指明了待读取数据的文件。read语句
会使用IFS字符解析读入的文本，我们在这里将IFS指定为逗号。
脚本中另外两处重定向操作出现在同一条语句中：
cat >> $outfile << EOF
这条语句中包含一个输出追加重定向（双大于号）和一个输入追加重定向（双小于号）。输
出重定向将cat命令的输出追加到由$outfile变量指定的文件中。cat命令的输入不再取自标准
输入，而是被重定向到脚本中存储的数据。EOF符号标记了追加到文件中的数据的起止。

第17章 创建函数 

17.1 基本的脚本函数
有两种格式可以用来在bash shell脚本中创建函数。第一种格式采用关键字function，后跟
分配给该代码块的函数名。
function name {
   commands
}

第二种格式更接近于其他编程语言中定义函数的方式。
name() {
  commands
}

如果在函数被定义前使用函数，会收到一条错误消息。

17.2 返回值
bash shell会把函数当作一个小型脚本，运行结束时会返回一个退出状态码;
17.2.1 默认退出状态码
默认情况下，函数的退出状态码是函数中最后一条命令返回的退出状态码。

17.2.2 使用return 命令
bash shell使用return命令来退出函数并返回特定的退出状态码。return命令允许指定一个
整数值来定义函数的退出状态码，从而提供了一种简单的途径来编程设定函数退出状态码。
 函数一结束就取返回值；
 退出状态码必须是0~255。
如果在用$?变量提取函数返回值之前执行了其他命令，函数的返回值就会丢失。记住，$?
变量会返回执行的最后一条命令的退出状态码。

会将dbl函数的输出赋给$result变量
result=$(dbl)

17.3 在函数中使用变量
17.3.1 向函数传递参数
---
#s.sh 
f(){
    echo $[ $1 + $2 ]
}

#在脚本中调用函数时，传递给函数的参数用$n引用
v=$(f 10 10)
echo " 10 + 10 = $v"
v=$(f 9 + 9)
echo "9 + 9 = $v"
----

----
#s2.sh
f(){
    echo $[ $1 + $2 ]
}

v=$(f)
echo $v
-----
#但是s2.sh中的f不能直接捕获命令行参数变量，要直接传给它
$ ./s2.sh 10 10

---
#s3.sh
f(){
    echo $[ $1 + $2 ]
}

v=$(f $1 $2)
echo $v
---
$./s3.sh 10 20 

17.3.2 在函数中处理变量
全局变量是在shell脚本中任何地方都有效的变量;
默认情况下，你在脚本中定义的任何变量都是全局变量；
#尽管va是全局变量，但是在f被调用时，它还未被定义；
#因此，函数调用时，变量必须被定义
    1 #!/bin/bash
      2
      3 vf=10
      4
      5 f(){
      6   echo $vf
      7   echo $va
      8 }
      9 va=20
     10 f
     11
     12 #va=20

2. 局部变量
2. 局部变量
无需在函数中使用全局变量，函数内部使用的任何变量都可以被声明成局部变量。要实现这
一点，只要在变量声明的前面加上local关键字就可以了
local关键字保证了变量只局限在该函数中。如果脚本中在该函数之外有同样名字的变量，
那么shell将会保持这两个变量的值是分离的

17.4 数组变量和函数
要解决这个问题，你必须将该数组变量的值分解成单个的值，然后将这些值作为函数参数使
用。在函数内部，可以将所有的参数重新组合成一个新的变量
#分解
func ${myarray[*]}
#合并
newarray=(echo "$@")
#语法
arg1=$(echo ${myarray[*]})
result=$(addarray $arg1) #传递参数

17.4.2 从函数返回数组
函数用echo语句来按正确顺序输出单个
数组值，然后脚本再将它们重新放进一个新的数组变量中。
func(){
    echo ${newarray[*]}
}
#特定的语法
arg1=$(echo ${myarray[*]})
result=($(func $arg1))
echo "The new array is: ${result[*]}" 

函数递归
function factorial {
if [ $1 -eq 1 ]
then
   echo 1
else
   local temp=$[ $1 - 1 ]
   local result=$(factorial $temp)
   echo $[ $result * $1 ]
fi
}

17.6 创建库
bash shell允许创建函数库文件，然后在多个脚本中引用该库文件。
1.创建一个包含脚本中所需函数的公用库文件myfuncs
/full/path/myfuncs
#myfuncs
f1(){

}

f2(){

}

2.在用到这些函数的脚本文件中包含myfuncs库文件。source命令会在当前shell上下文中执行命令，而不是
创建一个新shell。可以用source命令来在shell脚本中运行库文件脚本。这样脚本就可以使用库
中的函数了。
source命令有个快捷的别名，称作点操作符（dot operator）。
#s.sh
---START--- 
#!/bin/bash 
. /full/path/myfuns 
commands1
commands2
f1 
f2 
---END---

#不好的实践 
17.7 在命令行上使用函数 
在命令行上直接定义一个函数
1.一种方法是采用单行方式定义函数。
$ function divem { echo $[ $1 / $2 ]; }
当在命令行上定义函数时，在每个命令后面加个分号，这样shell就能知道在哪里
是命令的起止了。

另一种方法是采用多行方式来定义函数。在定义时，bash shell会使用次提示符来提示输入更
多命令。用这种方法，你不用在每条命令的末尾放一个分号，只要按下回车键就行。
$ function multem {
> echo $[ $1 * $2 ]
> }

17.7.2 在.bashrc 文件中定义函数
在命令行上直接定义shell函数的明显缺点是退出shell时，函数就消失了；
一个非常简单的方法是将函数定义在一个特定的位置，这个位置在每次启动一个新shell的时
候，都会由shell重新载入。
最佳地点就是.bashrc文件。bash shell在每次启动时都会在主目录下查找这个文件，不管是交
互式shell还是从现有shell中启动的新shell。
1. 直接定义函数
直接在主目录下的.bashrc文件中定义函数

2.2. 读取函数文件
只要是在shell脚本中，都可以用source命令（或者它的别名点操作符）将库文件中的函数
添加到你的.bashrc脚本中。

17.8 实例
$wget ftp://ftp.gnu.org/gnu/shtool/shtool-2.0.8.tar.gz
$tar -zxvf shtool-2.0.8.tar.gz
$ ./confifgure
$ make
$make install
shtool [options] [function [options] [args]]

$ cat test16
#!/bin/bash
shtool platform

$ ls –al /usr/bin | shtool prop –p "waiting..."
可以使用\、|、/和-字符创建一个旋转的进度条,-p选项允许你定制输出文
本，这段文本会出现在进度条字符之前

第19 章 初识sed和gawk

sed编辑器被称作流编辑器（stream editor），
sed命令的格式如下。
sed options script file
选项允许你修改sed命令的行为，可以使用的选项已在表19-1中列出。
表19-1 sed命令选项
选 项 描 述
-e script 在处理输入时，将script中指定的命令添加到已有的命令中
-f file 在处理输入时，将file中指定的命令添加到已有的命令中
-n 不产生命令输出，使用print命令来完成输出
script参数指定了应用于流数据上的单个命令。如果需要用多个命令，要么使用-e选项在
命令行中指定，要么使用-f选项在单独的文件中指定

1. 在命令行定义编辑器命令
$ echo "This is a test" | sed 's/test/big test/'
sed编辑器并不会修改文本文件的数据。它只会将修改后的数据发送到STDOUT

2. 在命令行使用多个编辑器命令
要在sed命令行上执行多个命令时，只要用-e选项就可以了。
$ sed -e 's/brown/green/; s/dog/cat/' data1.txt
命令之间必须用分号隔开，并且在命令末尾和分号
之间不能有空格。如果不想用分号，也可以用bash shell中的次提示符来分隔命令
sed -e '
> s/brown/green/
> s/fox/elephant/
> s/dog/cat/' data1.txt
要在封尾单引号所在行结束命令

3. 从文件中读取编辑器命令
$ sed -f script1.sed data1.txt
不用在每条命令后面放一个分号

19.1.2 gawk 程序
gawk options program file
-F fs 指定行中划分数据字段的字段分隔符
-f file 从指定的文件中读取程序
-v var=value 定义gawk程序中的一个变量及其默认值
-mf N 指定要处理的数据文件中的最大字段数
-mr N 指定数据文件中的最大数据行数
-W keyword 指定gawk的兼容模式或警告等级

2. 从命令行读取程序脚本
gawk程序脚本用一对花括号来定义,必须将脚本命令放到两个花括号（{}）中,
由于gawk命令行假定脚本是单个文本字符串，你还必须将脚本放到单引号中,
gawk程序会从STDIN接收数据
$ gawk '{print "Hello World!"}'
bash shell提供了一个组合键来生成
EOF（End-of-File）字符。Ctrl+D组合键会在bash中产生一个EOF字符。这个组合键能够终止该gawk
程序并返回到命令行界面提示符下。

3. 使用数据字段变量
默认情况下，gawk会将如下变量分配给它在文本行中发现的数据字段：
 $0代表整个文本行；
 $1代表文本行中的第1个数据字段；
 $2代表文本行中的第2个数据字段；
 $n代表文本行中的第n个数据字段。 //代表整个文本行，与 $0 相同
。gawk中默认的字段分隔符是任意的空白字符（例如空格或制
表符）。

4. 在程序脚本中使用多个命令
要在命令行上的程序脚本中使用多条命令，只要在命令之间放个分
号即可。
$ echo "My name is Rich" | gawk '{$4="Christine"; print $0}'
也可以用次提示符一次一行地输入程序脚本命令。
$ gawk '{
> $4="Christine"
> print $0}'
My name is Rich、

5. 从文件中读取程序
$ gawk -F: -f script2.gawk /etc/passwd
可以在程序文件中指定多条命令。要这么做的话，只要一条命令放一行即可，不需要用分号。
#注：但是，脚本文件中仍然要用花括号{},gawk程序在引用变量值时并未像shell脚本一样使用美元符。
#直接使用text 
$ cat script3.gawk
{
text = "'s home directory is "
print $1 text $6
}
gawk程序在引用变量值时并未像shell脚本一样使用美元符。

6. 在处理数据前运行脚本
BEGIN关键字就是用来做这个的。它会强制gawk在读取数据前执行BEGIN关键字后指定的程序脚本。
$ gawk 'BEGIN {print "Hello World!"}'
$ gawk BEGIN'{print "Hello"}'

7. 在处理数据后运行脚本
与BEGIN关键字类似，END关键字允许你指定一个程序脚本，gawk会在读完数据后执行它
gawk 'BEGIN {print "The data3 File Contents:"}
> {print $0}
> END {print "End of File"}' data3.txt
这是在处理完所有正常数据后给报告添加页脚的最佳方法。

19.2 sed 编辑器基础
#相对于行而言
替换命令在替换多行中的文本时能正常工作，但默认情况下它只替换每行中出现的第一处。
要让替换命令能够替换一行中不同地方出现的文本必须使用替换标记（substitution flag）。替换标
记会在替换命令字符串之后设置。
s/pattern/replacement/flags
有4种可用的替换标记：
 数字，表明新文本将替换第几处模式匹配的地方；
 g，表明新文本将会替换所有匹配的文本；
 p，打印修改过的行；
 w file，将替换的结果写到文件中

$ sed -n 's/test/trial/p' data5.txt
-n选项将禁止sed编辑器输出。但p替换标记会输出修改过的行。将二者配合使用的效果就是
只输出被替换命令修改过的行。

2. 替换字符
$ sed 's/\/bin\/bash/\/bin\/csh/' /etc/passwd
由于正斜线通常用作字符串分隔符，因而如果它出现在了模式文本中的话，必须用反斜线来
转义
sed编辑器允许选择其他字符来作为替换命令中的字符串分隔符：
$ sed 's!/bin/bash!/bin/csh!' /etc/passwd

19.2.2 使用地址
如果只想将命令作用
于特定行或某些行，则必须用行寻址（line addressing）。
在sed编辑器中有两种形式的行寻址：
 以数字形式表示行区间
 用文本模式来过滤出行

#与下面的应用举例不符
两种形式都使用相同的格式来指定地址：
[address]command
也可以将特定地址的多个命令分组：
address {
 command1
 command2
 command3
}

1. 数字方式的行寻址
sed编辑器会将文本流中的第一行编号为1，然后继续按顺序为接下来的行分配行号。
在命令中指定的地址可以是单个行号，或是用起始行号、逗号以及结尾行号指定的一定区间
范围内的行
$ sed '2s/dog/cat/' data1.txt
$ sed '2,3s/dog/cat/' data1.txt
如果想将命令作用到文本中从某行开始的所有行，可以用特殊地址——美元符。
$ sed '2,$s/dog/cat/' data1.txt

2. 使用文本模式过滤器
sed编辑器允许指定文本模式来过滤出命令要作用的行。格式如下：
/pattern/command
$ sed '/dog/s/dog/dogdog/' data1.txt 
#用法错误，不能混合使用行寻址与文本模式过滤
$ sed '/dog/1,$s/dog/dogdog/' data1.txt 

19.2.3 删除行
删除命令d名副其实，它会删除匹配指定寻址模式的所有行。使用该命令时要特别小心，如
果你忘记加入寻址模式的话，流中的所有文本行都会被删除。

可以从数据流中删除特定的文本行，通过行号指定：
$ sed '3d' data6.txt
通过特定行区间指定：
$ sed '2,3d' data6.txt
特殊的文件结尾字符：
$ sed '3,$d' data6.txt
sed编辑器的模式匹配特性也适用于删除命令。
$ sed '/number 1/d' data6.txt

ed编辑器不会修改原始文件。你删除的行只是从sed编辑器的输出中消失了。原始
文件仍然包含那些“删掉的”行。

#区间操作，有坑
也可以使用两个文本模式来删除某个区间内的行，但这么做时要小心。你指定的第一个模式
会“打开”行删除功能，第二个模式会“关闭”行删除功能。sed编辑器会删除两个指定行之间
的所有行（包括指定的行）。
$ sed '/1/,/3/d' data6.txt
$ sed '/1/,/5/d' data7.txt
$
因为删除功能在匹配到第一个模式的时候打开了，但一直没匹配到结束模式，所以整个数据
流都被删掉了。

要将新行附加到数据流的末尾，只要用代表数据最后一行的美元符就可以了。
$ sed '$a\xxx' file 

#注：还必须用如下次提示符的提示输出，表明每行
要插入或附加多行文本，就必须对要插入或附加的新文本中的每一行使用反斜线，直到最后
一行。
$ sed '1i\
> This is one line of new text.\
> This is another line of new text.' data6.txt

19.2.5 修改行 change
必须在sed命令中单独指定新行。
$ sed '3c\
> This is a changed line of text.' data6.txt

也可以用文本模式来寻址。
$ sed '/number 3/c\
> This is a changed line of text.' data6.txt

#注：修改替换了两行
$ sed '2,3c\
> This is a new line of text.' data6.txt

19.2.6 转换命令
转换（transform）命令（y）是唯一可以处理单个字符的sed编辑器命令。转换命令格式
如下。
[address]y/inchars/outchars/
转换命令会对inchars和outchars值进行一对一的映射。inchars中的第一个字符会被转
换为outchars中的第一个字符，第二个字符会被转换成outchars中的第二个字符。这个映射过
程会一直持续到处理完指定字符。如果inchars和outchars的长度不同，则sed编辑器会产生一
条错误消息。
$ sed 'y/123/789/' data8.txt
转换命令是一个全局命令，也就是说，它将文本行中找到的所有指定字符自动进行转换，而
不会考虑它们出现的位置。

19.2.7 回顾打印
另外有3个命令也能用
来打印数据流中的信息：
 p命令用来打印文本行；
 等号（=）命令用来打印行号；
 l（小写的L）命令用来列出行

1. 打印行
#模式匹配
$ sed -n '/number 3/p' data6.txt
This is line number 3.
在命令行上用-n选项，你可以禁止输出其他行，只打印包含匹配文本模式的行
$ sed -n '2,3p' data6.txt
#下面两个命令相同
$sed '/1|2|3|4/p' data1.txt
$sed -n '/[[:digit:]]/p' data1.txt

可以
创建一个脚本在修改行之前显示该行。
$ sed -n '/3/{
> p
> s/line/test/p
> }' data6.txt
This is line number 3.
This is test number 3.
$

2. 打印行号
等号命令会打印行在数据流中的当前行号。行号由数据流中的换行符决定。每次数据流中出
现一个换行符，sed编辑器会认为一行文本结束了。
如果你要在数据流中查找特定文本模式的话，
等号命令用起来非常方便。
$ sed -n '/number 4/{
> =
> p
> }' data6.txt

3. 列出行
列出（list）命令（l）可以打印数据流中的文本和不可打印的ASCII字符。任何不可打印
字符要么在其八进制值前加一个反斜线，要么使用标准C风格的命名法

$ cat data9.txt
This line contains tabs.
$
$ sed -n 'l' data9.txt
This\tline\tcontains\ttabs.$
$
制表符的位置使用\t来显示。行尾的美元符表示换行符。如果数据流包含了转义字符，列出
命令会在必要时候用八进制码来显示。

#将转义字符写入文本
echo -e "\a" > escape.txt

19.2.8 使用sed 处理文件
1. 写入文件
w命令用来向文件写入行。该命令的格式如下：
[address]w filename
filename可以使用相对路径或绝对路径，但不管是哪种，运行sed编辑器的用户都必须有文
件的写权限。地址可以是sed中支持的任意类型的寻址方式，例如单个行号、文本模式、行区间
或文本模式
如果你不想让行显示到STDOUT上，你可以用sed命令的-n选项

2. 从文件读取数据
读取（read）命令（r）允许你将一个独立文件中的数据插入到数据流中。
[address]r filename
filename参数指定了数据文件的绝对路径或相对路径。你在读取命令中使用地址区间，只
能指定单独一个行号或文本模式地址。sed编辑器会将文件中的文本插入到指定地址后。
$ sed '3r data12.txt' data6.txt
#将文本内容分别插入到1，2，3行后面
sed '1,3r data.txt' data1.txt
$ sed '/number 2/r data12.txt' data6.txt
在数据流的末尾添加文本，只需用美元符地址符；
$ sed '$r data12.txt' data6.txt

#在占位符后插入文件内容，再删除占位符；无法执行！
和删除命令配合使用：利用另一个文件中的数据来替换文件
中的占位文本。
$ cat notice.std
Would the following people:
LIST
please report to the ship's captain.
$
$ sed '/LIST/{
> r data11.txt
> d
> }' notice.std
Would the following people:
Blum, R Browncoat
McGuiness, A Alliance
Bresnahan, C Browncoat
Harken, C Alliance
please report to the ship's captain.
$

第20 章 正则表达式

在Linux中，有两种流行的正则表达式引擎：
 POSIX基础正则表达式（basic regular expression，BRE）引擎
 POSIX扩展正则表达式（extended regular expression，ERE）引擎

sed编辑器）只符合了BRE引擎规范的子集

POSIX BRE引擎通常出现在依赖正则表达式进行文本过滤的编程语言中。它为常见模式提供
了高级模式符号和特殊符号，比如匹配数字、单词以及按字母排序的字符。gawk程序用ERE引擎
来处理它的正则表达式模式。

20.2 定义BRE 模式
第一条原则就是：正则表达式模式都区分大小写。这意味着它们只会匹配大小写也相符
的模式。
$ echo "This is a test" | sed -n '/this/p'

正则表达式识别的特殊字符包括：
.*[]^${}\+?|()

#正斜线也需要转义，
#诡异的是 
$echo "\fuck" | sed -n "/\\/p"  错误
$echo "\fuck" | sed -n '/\\/p'  正确
由于反斜线是特殊字符，如果要在正则表达式模式中使用它，你必须对其转义，这样就产生
了两个反斜线。
$ echo "\ is a special character" | sed -n '/\\/p'
\ is a special character
$
最终，尽管正斜线不是正则表达式的特殊字符，但如果它出现在sed编辑器或gawk程序的正
则表达式中，你就会得到一个错误。
$ echo "3 / 2" | sed -n '///p'
sed: -e expression #1, char 2: No previous regular expression
$
要使用正斜线，也需要进行转义。
$ echo "3 / 2" | sed -n '/\//p'
3 / 2

20.2.3 锚字符
1. 锁定在行首
脱字符（^）定义从数据流中文本行的行首开始的模式。
echo "Books are great" | sed -n '/^Book/p'

如果你将脱字符放到模式开头之外的其他位置，那么它就跟普通字符一样，不再是特殊字符了：
$echo "This ^ is a test" | sed -n '/s \^/p'
$echo "This ^ is a test" | sed -n '/s ^/p'
如果指定正则表达式模式时只用了脱字符，就不需要用反斜线来转义。但如果你在模式
中先指定了脱字符，随后还有其他一些文本，那么你必须在脱字符前用转义字符。

2. 锁定在行尾
特殊字符美元符（$）定义了行尾锚点

3.组合锚点
将两个锚点直接组合在一起，之间不加任何文本，这样过滤出数据流中的空白行
文档中删除空白行的有效方法。
sed  '/^$/d' data.txt

特殊字符点号用来匹配除换行符之外的任意单个字符。它必须匹配一个字符，如果在点号字
符的位置没有字符，那么模式就不成立。

20.2.5 字符组
可以定义用来匹配文本模式中某个位置的一组字符。如果字符组中的某个字符出现在了数据
流中，那它就匹配了该模式。
方括号来定义一个字符组;
字符组中必须有个字符来匹配相应的位置;
在不太确定某个字符的大小写时，字符组会非常有用。
可以在单个表达式中用多个字符组。
#匹配单个字符
$ echo "Yes" | sed -n '/[Yy][Ee][Ss]/p'

20.2.6 排除型字符组
寻找组中没有的字符，而不是去寻找
在字符组的开头加个脱字符。
echo "fuck" | sed -n "/fu[^y]k/p"

20.2.7 区间
用单破折线符号在字符组
中表示字符区间。只需要指定区间的第一个字符、单破折线以及区间的最后一个字符就行了。根
据Linux系统采用的字符集（参见第2章），正则表达式会包括此区间内的任意字符
可以在单个字符组指定多个不连续的区间
[0-9a-zA-Z]

20.2.8 特殊的字符组
表20-1 BRE特殊字符组
组 描 述
[[:alpha:]] 匹配任意字母字符，不管是大写还是小写
[[:alnum:]] 匹配任意字母数字字符0~9、A~Z或a~z
[[:blank:]] 匹配空格或制表符
[[:digit:]] 匹配0~9之间的数字
[[:lower:]] 匹配小写字母字符a~z
[[:print:]] 匹配任意可打印字符
[[:punct:]] 匹配标点符号
[[:space:]] 匹配任意空白字符：空格、制表符、NL、FF、VT和CR
[[:upper:]] 匹配任意大写字母字符A~Z

20.2.9 星号
在字符后面放置星号表明该字符必须在匹配模式的文本中出现0次或多次。
$ echo "fuuuuk" | sed -n "/fu*k/p"
这个模式符号广泛用于处理有常见拼写错误或在不同语言中有拼写变化的单词
$ echo "I'm getting a color TV" | sed -n '/colou*r/p'

# 点号无法匹配换行符
将点号特殊字符和星号特殊字符组合起来。这个组合能够匹配任意数量
的任意字符。它通常用在数据流中两个可能相邻或不相邻的文本字符串之间。
echo "fuaeaeuuuk" | sed -n '/f.*k/p'
星号还能用在字符组上。它允许指定可能在文本中出现多次的字符组或字符区间。

20.3 扩展正则表达式
#总结
gawk程序能够识别ERE模式，但sed编辑器不能。
问号? 加号+ 花括号{} 管道符号| 圆括号()表达式分组
必须指定gawk程序的--re-interval命令行选项才能识别正则表达式间隔

本节将介绍可用在gawk程序脚本中的较常见的ERE模式符号。
20.3.1 问号
问号表明前面的字符可以出现0次或1次
echo "fuck" | gawk -n '/f[u]?ck/{print $0}'

#如果字符组中的字符出现了0次或1次，模式匹配就成立。但如果两个字符都出现了，或者其
#中一个字符出现了2次，模式匹配就不成立
echo "fuck" | gawk -n '/f[uc]?k/{print $0}'

20.3.2 加号
加号表明前面的字符可以出现1次或多次，但必须至少出现1次
echo "fuck" | gawk -n '/f[uc]+k/{print $0}'

20.3.3 使用花括号
这通常称为间隔（interval）。
可以用两种格式来指定区间。
 m：正则表达式准确出现m次。
 m, n：正则表达式至少出现m次，至多n次

必须指定gawk程序的--re-interval命令行选项才能识别正则表达式间隔。
echo "fuuuuck" | gawk --re-interval '/fu{4}ck/{print $0}'
echo "fuuuuck" | gawk --re-interval '/f[uc]{1,100}ck/{print $0}'

20.3.4 管道符号
expr1|expr2|...
正则表达式和管道符号之间不能有空格，否则它们也会被认为是正则表达式模式的一部分。
echo "fuck fucker fonker" | gawk  '/fuck|fucker|fonker/{print $0}'

20.3.5 表达式分组
正则表达式模式也可以用圆括号进行分组。当你将正则表达式模式分组时，该组会被视为一
个标准字符；
echo "cat" | gawk '/(c|b)a(b|t)/{print $0}'


第 21 章 sed进阶

21.1.1 next 命令
1. 单行的next命令
n命令会让sed编辑器移动到文本的下一行
sed '/header/{n ; d}' data1.txt

2. 合并文本行
单行next命令会将数据流中的下一文本
行移动到sed编辑器的工作空间（称为模式空间）。多行版本的next命令（用大写N）会将下一文
本行添加到模式空间中已有的文本后
#换行符的正则匹配符是 \n 
sed '/first/{ N ; s/\n/ / }' data2.txt
用N命令将下一行合并到那行，然后用替换命令s将换行符替换成空格

$ cat data4.txt
On Tuesday, the Linux System
Administrator's group meeting will be held.
All System Administrators should attend.
$
$ sed 'N
> s/System\nAdministrator/Desktop\nUser/
> s/System Administrator/Desktop User/
> ' data4.txt
On Tuesday, the Linux Desktop
User's group meeting will be held.
All System Administrators should attend.
$
由于System Administrator文本出现在了数据流中的最后一行，N命令会错过它，因为没
有其他行可读入到模式空间跟这行合并。你可以轻松地解决这个问题——将单行命令放到N命令
前面，并将多行命令放到N命令后面，
$ sed '
> s/System Administrator/Desktop User/
> N
> s/System\nAdministrator/Desktop\nUser/
> ' data4.txt
On Tuesday, the Linux Desktop
User's group meeting will be held.
All Desktop Users should attend.

21.1.2 多行删除命令
$ sed 'N ; /System\nAdministrator/d' data4.txt
All System Administrators should attend.
$
删除命令会在不同的行中查找单词System和Administrator，然后在模式空间中将两行都删掉。
sed编辑器提供了多行删除命令D，它只删除模式空间中的第一行。该命令会删除到换行符（含
换行符）为止的所有字符。

#sed编辑器脚本会查找空白行，然后用N命令来将下一文本行添加到模式空间。如果新的模式
#空间内容含有单词header，则D命令会删除模式空间中的第一行;
#注：在模式空间查找
sed '/^$/{N ; /header/D}' data5.txt

#存疑
当多行匹配出现时，P命令只会打印模式空间中的第一行。多行P命令的强大之处在和N命令
及D命令组合使用时才能显现出来。
D命令的独特之处在于强制sed编辑器返回到脚本的起始处，对同一模式空间中的内容重新执
行这些命令（它不会从数据流中读取新的文本行）。在命令脚本中加入N命令，你就能单步扫过整
个模式空间，将多行一起匹配。
接下来，使用P命令打印出第一行，然后用D命令删除第一行并绕回到脚本的起始处。一旦返
回，N命令会读取下一行文本并重新开始这个过程。这个循环会一直继续下去，直到数据流结束。

21.2 保持空间
模式空间（pattern space）是一块活跃的缓冲区，在sed编辑器执行命令时它会保存待检查的
文本。但它并不是sed编辑器保存文本的唯一空间。
sed编辑器有另一块称作保持空间（hold space）的缓冲区域。在处理模式空间中的某些行时，
可以用保持空间来临时保存一些行
表21-1 sed编辑器的保持空间命令
命 令 描 述
h 将模式空间复制到保持空间
H 将模式空间附加到保持空间
g 将保持空间复制到模式空间
G 将保持空间附加到模式空间
x 交换模式空间和保持空间的内容

21.3 排除命令 --奇妙的用法
感叹号命令（!）用来排除（negate）命令，也就是让原本会起作用的命令不起作用

#-n 与 p
$ sed -n '/header/!p' data2.txt
This is the first data line.
This is the second data line.
This is the last line.
$
普通p命令只打印data2文件中包含单词header的那行。加了感叹号之后，情况就相反了：除
了包含单词header那一行外，文件中其他所有的行都被打印出来了。

#
$ sed '$!N;
> s/System\nAdministrator/Desktop\nUser/
> s/System Administrator/Desktop User/
> ' data4.txt
On Tuesday, the Linux Desktop
User's group meeting will be held.
All Desktop Users should attend.
$
这个例子演示了如何配合使用感叹号与N命令以及与美元符特殊地址。美元符表示数据流中
的最后一行文本，所以当sed编辑器到了最后一行时，它没有执行N命令，但它对所有其他行都执
行了这个命令。

唯一的问题是你不想将保持空间附加到要处理的第一行文本后面。这可以用感叹号命令轻松解决：
1!G

#反转文本行，图21-1，算法图，通过两个缓冲实现；tac命令会倒序显示一个文本文件
sed -n '{1!G ; h ; $p }' data2.txt

21.4 改变流
sed编辑器会从脚本的顶部开始，一直执行到脚本的结尾（D命令是个例外，它会强制
sed编辑器返回到脚本的顶部，而不读取新的行）。sed编辑器提供了一个方法来改变命令脚本的执
行流程，其结果与结构化编程类似。

21.4.1 分支
分支（branch）命令b的格式如下：
[address]b [label]
address参数决定了哪些行的数据会触发分支命令。label参数定义了要跳转到的位置。如
果没有加label参数，跳转命令会跳转到脚本的结尾
#标签以冒号开始，最多可以是7个字符长度。:label2
#当匹配分支模式，会跳到commands2；不匹配时，只执行commands1
sed '{/pattern/b label; commands1; :label; commands2}' file.txt 

#循环；<内部工作流程是怎样的>,跳转标签前置
echo "This, is, a, test, to, remove, commas." | sed -n '{
> :start
> s/,//1p   #s/,//p也行
> /,/b start
> }'

21.4.2 测试
测命令会根据替换命令的结果跳转到某个标签，而不是根据地址进行跳转。
如果替换命令成功匹配并替换了一个模式，测试命令就会跳转到指定的标签。如果替换命令
未能匹配指定的模式，测试命令就不会跳转。
[address]t [label]
跟分支命令一样，在没有指定标签的情况下，如果测试成功，sed会跳转到脚本的结尾。

echo "This, is, a, test, to, remove, commas. " | sed -n '{
> :start
> s/,//1p
> t start
> }'

21.5.1 &符号
&符号可以用来代表替换命令中的匹配的模式。
$ echo "The cat sleeps in his hat." | sed 's/.at/"&"/g'

sed编辑器用圆括号来定义替换模式中的子模式。你可以在替代模式中使用特殊字符来引用
每个子模式。替代字符由反斜线和数字组成。数字表明子模式的位置。sed编辑器会给第一个子
模式分配字符\1，给第二个子模式分配字符\2，依此类推。

当在替换命令中使用圆括号时，必须用转义字符将它们标示为分组字符而不是普通的圆
括号

echo "The System Administrator manual" | sed '
> s/\(System\) Administrator/\1 User/'

#(.*[0-9]),匹配1234也说得过去
$ echo "1234567" | sed '{
> :start
> s/\(.*[0-9]\)\([0-9]\{3\}\)/\1,\2/
> t start
> }'
1,234,567

21.6 在脚本中使用sed
./reverse.sh data2.txt

21.6.2 重定向sed 的输出
可以在脚本中用$()将sed编辑器命令的输出重定向到一个变量中
v=$(echo "fuck" | sed 's/fuck/fucker/')

21.7 创建sed 实用工具
21.7.1 加倍行间距
$ sed 'G' data2.txt
#错误
$ sed "G" data2.txt
G命令会简单地将保持空间内容附加到模式空间内容后。当启动sed编辑器时，保持空间只有一个空行。将它附加到已有
行后面，你就在已有行后面创建了一个空白行 ；

如果你不想要这个空白行，可以用排除符号（!）和尾行符号（$）来确
保脚本不会将空白行加到数据流的最后一行后面。
$ sed '$!G' data2.txt

21.7.2 对可能含有空白行的文件加倍行间距
$ sed '/^$/d ; $!G' data6.txt
这个问题的解决办法是，首先删除数据流中的
所有空白行，然后用G命令在所有行后插入新的空白行。要删除已有的空白行，需要将d命令和一
个匹配空白行的模式一起使用。

21.7.3 给文件中的行编号
在获得了等号命令的输出之后，你可以通过管道将输出传给另一个sed编辑器脚本，它会使
用N命令来合并这两行
$ sed '=' data2.txt | sed 'N; s/\n/ /'

有些bash shell命令也可以添加行号，但它们会另外加入一些东西
#是字母l,不是数字1
$nl data2.txt 
$cat -n data2.txt

21.7.4 打印末尾行
#最后一行
$ sed -n '$p' data2.txt

创建滚动窗口显示数据流末尾的若干行：
滚动窗口是检验模式空间中文本行块的常用方法，它使用N命令将这些块合并起来。N命令将
下一行文本附加到模式空间中已有文本行后面。一旦你在模式空间有了一个10行的文本块，你可
以用美元符来检查你是否已经处于数据流的尾部。如果不在，就继续向模式空间增加行，同时删
除原来的行（记住，D命令会删除模式空间的第一行）。

#精巧的代码；
#退出（quit）命令会停止循环。N命令会将下一行附加到模式空间中当前行之后。如果当前行在第10行后面，11,$D命令会
#删除模式空间中的第一行
$ sed '{
> :start
> $q ; N ; 11,$D
> b start
> }' data7.txt

21.7.5 删除行
1. 删除连续的空白行
#19.2.3 删除行
/./,/^$/!d
区间是/./到/^$/。区间的开始地址会匹配任何含有至少一个字符的行。区间的结束地址会
匹配一个空行。在这个区间内的行不会被删除;

2. 删除开头的空白行--反向思考
/./,$!d
这个区间从含有字符的行开始，一直到数据流结束。在这个区间内的任何行都不会从输出中删除。这意味着含
有字符的第一行之前的任何行都会删除。

3. 删除结尾的空白行
#N-前进，:start 循环
sed '{
:start
/^\n*$/{$d; N; b start }
}'

地址模式能够匹配只含有一个换行
符的行。如果找到了这样的行，而且还是最后一行，删除命令会删掉它。如果不是最后一行，N
命令会将下一行附加到它后面，分支命令会跳到循环起始位置重新开始。

21.7.6 删除HTML 标签
$ sed 's/<[^>]*>//g ; /^$/d' data11.txt

第 22 章 gawk进阶

22.1 使用变量
gawk编程语言支持两种不同类型的变量：
 内建变量
 自定义变量

22.1.1 内建变量
1. 字段和记录分隔符变量
gawk中的一种内建变量类型——数据字段变量。数据字段变量允许你使用美元，
符号（$）和字段在该记录中的位置值来引用记录对应的字段。因此，要引用记录中的第一个数
据字段，就用变量$1；要引用第二个字段，就用$2，依次类推。
数据字段是由字段分隔符来划定的。默认情况下，字段分隔符是一个空白字符，也就是空格
符或者制表符。使用命令行参数-F或者在gawk程序中使用特殊的内
建变量FS来更改字段分隔符
表22-1 gawk数据字段和记录变量
变 量 描 述
FIELDWIDTHS 由空格分隔的一列数字，定义了每个数据字段确切宽度
FS 输入字段分隔符
RS 输入记录分隔符
OFS 输出字段分隔符
ORS 输出记录分隔符

一旦设置了FIELDWIDTH变量，gawk就会忽略FS变量，并根据提供的字段宽度来计算字段。
$ gawk 'BEGIN{FIELDWIDTHS="3 5 2 5"}{print $1,$2,$3,$4}' data1b
一定要记住，一旦设定了FIELDWIDTHS变量的值，就不能再改变了。这种方法并不适用
于变长的字段。
#gawk 'BEGIN{FIELDWIDTHS="1 1 1 10"}{FIELDWIDTHS="2 3 1 12"}{print $1,$2,$3,$4}' data1.txt

变量RS和ORS定义了gawk程序如何处理数据流中的字段。默认情况下，gawk将RS和ORS设为
换行符。默认的RS值表明，输入数据流中的每行新文本就是一条新纪录。
在数据流中碰到占据多行的字段，可以把RS变量设置成空字符串，然后在数据记录间留一个空白行。gawk会
把每个空白行当作一个记录分隔符。
gawk 'BEGIN{FS="\n"; RS=""} {print $1,$4}' data2

2. 数据变量
表22-2 更多的gawk内建变量
变 量 描 述
ARGC 当前命令行参数个数
ARGIND 当前文件在ARGV中的位置
ARGV 包含命令行参数的数组
CONVFMT 数字的转换格式（参见printf语句），默认值为%.6 g
ENVIRON 当前shell环境变量及其值组成的关联数组
ERRNO 当读取或关闭输入文件发生错误时的系统错误号
FILENAME 用作gawk输入数据的数据文件的文件名
FNR 当前数据文件中的数据行数
IGNORECASE 设成非零值时，忽略gawk命令中出现的字符串的字符大小写
NF 数据文件中的字段总数
NR 已处理的输入记录数
OFMT 数字的输出格式，默认值为%.6 g
RLENGTH 由match函数所匹配的子字符串的长度
RSTART 由match函数所匹配的子字符串的起始位置

gawk并不会将程序脚本当成命令
行参数的一部分。
$ gawk 'BEGIN{print ARGC,ARGV[1]}' data1
2 data1
$
ARGC变量表明命令行上有两个参数。这包括gawk命令和data1参数；

#说明 跟shell变量不同，在脚本中引用gawk变量时，变量名前不加美元符。

ENVIRON：关联数组用文本作为数组的索引值，而不是数值。

NF变量含有数据文件中最后一个数据字段的数字值。可以在它前面加个美元符将其用作字段
变量。

FNR变量含有当前数据文件中已处理过的记录数，NR变量则含有已处理过的记录总数
如果只使用一个数据文件作为输入， FNR和NR的值是相同的；如果使用多
个数据文件作为输入， FNR的值会在处理每个数据文件时被重置，而NR的值则会继续计数直到处
理完所有的数据文件。

如果你发现在不同的shell脚本中用到了同样的gawk脚本，记着将这段gawk脚本放到一个单独的文件中，并
用-f参数来在shell脚本中引用它；

22.1.2 自定义变量
自定义变量以字母、数字和下划线，但不能以数字开头。重要的是，要记住gawk变
量名区分大小写。
1. 在脚本中给变量赋值
$ gawk 'BEGIN{x=4; x= x * 2 + 3; print x}'

2. 在命令行上给变量赋值
也可以用gawk命令行来给程序中的变量赋值
$ cat script1
BEGIN{FS=","}
{print $n}
$ gawk -f script1 n=2 data1

使用命令行参数来定义变量值会有一个问题。在你设置了变量后，这个值在代码的BEGIN部
分不可用。
$ cat script2
BEGIN{print "The starting value is",n; FS=","}
{print $n}
$ gawk -f script2 n=3 data1
The starting value is
data13
data23
data33
$
可以用-v命令行参数来解决这个问题。它允许你在BEGIN代码之前设定变量。在命令行上，
-v命令行参数必须放在脚本代码之前。

22.2 处理数组
gawk编程语言使用关联数组提供数组功能。关联数组跟数字数组不同之处在于它的索引值
可以是任意文本字符串。

22.2.1 定义数组变量
可以用标准赋值语句来定义数组变量。数组变量赋值的格式如下：
var[index] = element
其中var是变量名，index是关联数组的索引值，element是数据元素值

22.2.2 遍历数组变量
如果要在gawk中遍历一个关联数组，可以用for语句的一种特殊形式。
for (var in array)
{
    statements
}
这个for语句会在每次循环时将关联数组array的下一个索引值赋给变量var，然后执行一
遍statements。重要的是记住这个变量中存储的是索引值而不是数组元素值；

#可以用数字做索引；数组打印出来是无序的
gawk 'BEGIN{
a[1]=12
a["b"]=16
for(i in a){
print "Index:",i, "value="a[i]
}
delete a[1]
print a[1]
}'
Index: b value=16
Index: 1 value=12

22.3 使用模式
在使用正则表达式时，正则表达式必须出现在它要控制的程序脚本的左花括号前。
$ gawk 'BEGIN{FS=","} /11/{print $1}' data1

22.3.2 匹配操作符
匹配操作符（matching operator）允许将正则表达式限定在记录中的特定数据字段。匹配操
作符是波浪线（~）。可以指定匹配操作符、数据字段变量以及要匹配的正则表达式。
$1 ~ /^data/
$1变量代表记录中的第一个数据字段。这个表达式会过滤出第一个字段以文本data开头的
所有记录

$ gawk 'BEGIN{FS=","} $2 ~ /^data2/{print $0}' data1
匹配操作符会用正则表达式/^data2/来比较第二个数据字段，该正则表达式指明字符串要
以文本data2开头

可以用!符号来排除正则表达式的匹配。
$1 !~ /expression/

22.3.3 数学表达式
可以使用任何常见的数学比较表达式。
 x == y：值x等于y。
 x <= y：值x小于等于y。
 x < y：值x小于y。
 x >= y：值x大于等于y。
 x > y：值x大于y。
显示所有属于root用户组（组ID为0）的系统用户
$ gawk -F: '$4 == 0{print $1}' /etc/passwd

也可以对文本数据使用表达式，但跟正则表达式不同，表达式必须完全匹配。数
据必须跟模式严格匹配。
$ gawk -F, '$1 == "data"{print $1}' data1

22.4 结构化命令
if (condition)
    statement1
也可以将它放在一行上，像这样：
if (condition) statement1
如果需要在if语句中执行多条语句，就必须用花括号将它们括起来。
gawk的if语句也支持else子句;
可以在单行上使用else子句，但必须在if语句部分之后使用分号。
 gawk '{
> if($0 < 50){
    #print $0*10
>    x=$0*10
>    print x
> }
> else{
>    print $0
> }}' data3.txt

22.4.2 while 语句
while (condition)
{
statements
}

gawk编程语言支持在while循环中使用break语句和continue语句,
#计算每行的和
gawk '{
    n=NF
    print "this is line "NR
    sum=0
    while(n>0){
       sum=sum+$n 
       n=n-1
    }
    print "sum of line "NR" is "sum 
}' data3.txt 

22.4.3 do-while 语句
do-while语句类似于while语句，但会在检查条件语句之前执行命令。
do
{
   statements
} while (condition)

22.4.4 for 语句
gawk编程语言支持C风格的for循环。
for( variable assignment; condition; iteration process)
gawk '{
    print "this is line "NR
    sum=0
    for(n=NF;n>0;n--){
       sum=sum+$n 
    }
    print "sum of line "NR" is "sum 
}' data3.txt 

22.5 格式化打印
C语言:
printf "format string", var1, var2 . . .
格式化指定符
%[modifier]control-letter
表22-3 格式化指定符的控制字母
控制字母 描 述
c 将一个数作为ASCII字符显示
d 显示一个整数值
i 显示一个整数值（跟d一样）
e 用科学计数法显示一个数
f 显示一个浮点值
g 用科学计数法或浮点数显示（选择较短的格式）
o 显示一个八进制值
s 显示一个文本字符串
x 显示一个十六进制值
X 显示一个十六进制值，但用大写字母A~F

有3种修饰符可以用来进一步控制输出。
 width：指定了输出字段最小宽度的数字值。如果输出短于这个值，printf会将文本右
对齐，并用空格进行填充。如果输出比指定的宽度还要长，则按照实际的长度输出。
 prec：这是一个数字值，指定了浮点数中小数点后面位数，或者文本字符串中显示的最
大字符数。
 -（减号）：指明在向格式化空间中放入数据时采用左对齐而不是右对齐
需要在printf命令的末尾手动添加换行符来生成新行。没添加的话，printf命令
会继续在同一行打印后续输出

22.6 内建函数
表22-4 gawk数学函数
函 数 描 述
atan2(x, y) x/y的反正切，x和y以弧度为单位
cos(x) x的余弦，x以弧度为单位
exp(x) x的指数函数
int(x) x的整数部分，取靠近零一侧的值
log(x) x的自然对数
rand( ) 比0大比1小的随机浮点值
sin(x) x的正弦，x以弧度为单位
sqrt(x) x的平方根
srand(x) 为计算随机数指定一个种子值

产生较大整数随机数的常见方法是用rand()函数和int()函数创建一个算法。
x = int(10 * rand())

在使用一些数学函数时要小心，因为gawk语言对于它能够处理的数值有一个限定区间。如果
超出了这个区间，就会得到一条错误消息；


除了标准数学函数外，gawk还支持一些按位操作数据的函数。
 and(v1, v2)：执行值v1和v2的按位与运算。
 compl(val)：执行val的补运算。
 lshift(val, count)：将值val左移count位。
 or(v1, v2)：执行值v1和v2的按位或运算。
 rshift(val, count)：将值val右移count位。
 xor(v1, v2)：执行值v1和v2的按位异或运算

表22-5 gawk字符串函数
函 数 描 述
asort(s [,d]) 将数组s按数据元素值排序。索引值会被替换成表示新的排序顺序的连续数字。另外，
如果指定了d，则排序后的数组会存储在数组d中
asorti(s [,d]) 将数组s按索引值排序。生成的数组会将索引值作为数据元素值，用连续数字索引来表
明排序顺序。另外如果指定了d，排序后的数组会存储在数组d中
gensub(r, s, h [, t]) 查找变量$0或目标字符串t（如果提供了的话）来匹配正则表达式r。如果h是一个以g
或G开头的字符串，就用s替换掉匹配的文本。如果h是一个数字，它表示要替换掉第h
处r匹配的地方
gsub(r, s [,t]) 查找变量$0或目标字符串t（如果提供了的话）来匹配正则表达式r。如果找到了，就
全部替换成字符串s
index(s, t) 返回字符串t在字符串s中的索引值，如果没找到的话返回0
length([s]) 返回字符串s的长度；如果没有指定的话，返回$0的长度
match(s, r [,a]) 返回字符串s中正则表达式r出现位置的索引。如果指定了数组a，它会存储s中匹配正
则表达式的那部分

函 数 描 述
split(s, a [,r]) 将s用FS字符或正则表达式r（如果指定了的话）分开放到数组a中。返回字段的总数
sprintf(format,
variables)
用提供的format和variables返回一个类似于printf输出的字符串
sub(r, s [,t]) 在变量$0或目标字符串t中查找正则表达式r的匹配。如果找到了，就用字符串s替换
掉第一处匹配
substr(s, i [,n]) 返回s中从索引值i开始的n个字符组成的子字符串。如果未提供n，则返回s剩下的部
分
tolower(s) 将s中的所有字符转换成小写
toupper(s) 将s中的所有字符转换成大写
函 数 描 述
mktime(datespec) 将一个按YYYY MM DD HH MM SS [DST]格式指定的日期转换成时间戳值①
strftime(format
[,timestamp])
将当前时间的时间戳或timestamp（如果提供了的话）转化格式化日期（采用shell
函数date()的格式）
systime( ) 返回当前时间的时间戳

22.7 自定义函数
function name([variables])
{
   statements
}
函数还能用return语句返回值;
在定义函数时，它必须出现在所有代码块之前（包括BEGIN代码块）。

gawk 'function pp(p){
   print "fucker"
   return p*p 
}
BEGIN{r=pp(10); print r}'

22.7.3 创建函数库
创建一个存储所有gawk函数的文件funclib,使用时，用-f选项装载,
$cat funclib
function f1(){

}

function f2(){

}
#脚本使用了函数f1
$cat script.sh
'BEGIN{
f1()
}'

$ gawk -f funclib -f script.sh data 

