第 16 章 控制脚本

表16-1 Linux信号
信 号 值 描 述
1 SIGHUP 挂起进程
2 SIGINT 终止进程
3 SIGQUIT 停止进程
9 SIGKILL 无条件终止进程
15 SIGTERM 尽可能终止进程
17 SIGSTOP 无条件停止进程，但不是终止进程
18 SIGTSTP 停止或暂停进程，但不终止进程
19 SIGCONT 继续运行停止的进程

默认情况下，bash shell会忽略收到的任何SIGQUIT (3)和SIGTERM (5)信号（正因为这样，
交互式shell才不会被意外终止）。但是bash shell会处理收到的SIGHUP (1)和SIGINT (2)信号。
如果bash shell收到了SIGHUP信号，比如当你要离开一个交互式shell，它就会退出。但在退
出之前，它会将SIGHUP信号传给所有由该shell所启动的进程（包括正在运行的shell脚本）。
通过SIGINT信号，可以中断shell。Linux内核会停止为shell分配CPU处理时间。这种情况发
生时，shell会将SIGINT信号传给所有由它所启动的进程，以此告知出现的状况。

Ctrl+Z组合键会生成一个SIGTSTP信号，停止shell中运行的任何进程。
如果在有已停止作业存在的情况下，你仍旧想退出shell，只要再输入一遍exit命令就行了。
shell会退出，终止已停止作业。或者，既然你已经知道了已停止作业的PID，就可以用kill命令
来发送一个SIGKILL信号来终止它。
$sleep 10
$ kill -9 2456
在终止作业时，最开始你不会得到任何回应。但下次如果你做了能够产生shell提示符的操作
（比如按回车键），你就会看到一条消息，显示作业已经被终止了

trap命令允许你来指定shell
脚本要监看并从shell中拦截的Linux信号。如果脚本收到了trap命令中列出的信号，该信号不再
由shell处理，而是交由本地处理。
trap命令的格式是：
trap commands signals
在trap命令行上，你只要列出想要shell执行的命令，以及一组用空格分开的待捕
获的信号

在shell脚本退出时进行捕获,
要捕获shell脚本的退出，只要在trap命令后加上EXIT信号就行。
trap "echo Goodbye..." EXIT 

16.1.5 修改或移除捕获
要想在脚本中的不同位置进行不同的捕获处理，只需重新使用带有新选项的trap命令。
也可以删除已设置好的捕获。只需要在trap命令与希望恢复默认行为的信号列表之间加上
两个破折号
trap -- SIGINT
也可以在trap命令后使用单破折号来恢复信号的默认行为。单破折号和双破折号都可以
正常发挥作用。

16.2.1 后台运行脚本
要在命令后加个&符;
当后台进程运行时，它仍然会使用终端显示器来显示STDOUT和STDERR;
注意，在ps命令的输出中，每一个后台进程都和
终端会话（pts/0）终端联系在一起。如果终端会话退出，那么后台进程也会随之退出。
当你要退出终端会话时，要是存在被停止的进程，会出现警告信息。
但如果使用了后台进程，只有某些终端仿真器会在你退出终端会话前提醒你还有后台作
业在运行。

16.3 在非控制台下运行脚本
有时你会想在终端会话中启动shell脚本，然后让脚本一直以后台模式运行到结束，即使你退
出了终端会话。这可以用nohup命令来实现。
#忽视SIGINT信号吧？
nohup命令运行了另外一个命令来阻断所有发送给该进程的SIGHUP信号。这会在退出终端会
话时阻止进程退出。
$ nohup ./test1.sh &
由于nohup命令会解除终端与进程的关联，进程也就不再同STDOUT和STDERR联系在一起。
为了保存该命令产生的输出，nohup命令会自动将STDOUT和STDERR的消息重定向到一个名为
nohup.out的文件中。

16.4.1 查看作业
jobs命令
脚本用$$变量来显示Linux系统分配给该脚本的PID；

表16-2 jobs命令参数
参 数 描 述
-l 列出进程的PID以及作业号
-n 只列出上次shell发出的通知后改变了状态的作业
-p 只列出作业的PID
-r 只列出运行中的作业
-s 只列出已停止的作业

带加号的作业会被当做默认作业。在使用
作业控制命令时，如果未在命令行指定任何作业号，该作业会被当成作业控制命令的操作对象。
当前的默认作业完成处理后，带减号的作业成为下一个默认作业。任何时候都只有一个带加
号的作业和一个带减号的作业，不管shell中有多少个正在运行的作业。


重启停止的作业
在bash作业控制中，可以将已停止的作业作为后台进程或前台进程重启。前台进程会接管你
当前工作的终端，所以在使用该功能时要小心了。
要以后台模式重启一个作业，可用bg命令加上作业号。

#foreground
要以前台模式重启作业，可用带有作业号的fg命令。

在多任务操作系统中（Linux就是），内核负责将CPU时间分配给系统上运行的每个进程。调
度优先级（scheduling priority）是内核分配给进程的CPU时间（相对于其他进程）。在Linux系统
中，由shell启动的所有进程的调度优先级默认都是相同的。
调度优先级是个整数值，从-20（最高优先级）到+19（最低优先级）。默认情况下，bash shell
以优先级0来启动所有进程。

nice命令允许你设置命令启动时的调度优先级。要让命令以更低的优先级运行，只要用nice
的-n命令行来指定新的优先级级别。
nice -n 10 ./test4.sh > test4.out &
ps -p 4973 -o pid,ppid,ni,cmd
必须将nice命令和要启动的命令放在同一行中，
nice命令阻止普通系统用户来提高命令的优先级，
nice命令的-n选项并不是必须的，只需要在破折号后面跟上优先级，

有时你想改变系统上已运行命令的优先级。这正是renice命令可以做到的。它允许你指定
运行进程的PID来改变它的优先级。

renice命令会自动更新当前运行进程的调度优先级。和nice命令一样，renice命令也有一
些限制：
 只能对属于你的进程执行renice；
 只能通过renice降低进程的优先级；
 root用户可以通过renice来任意调整进程的优先级。

16.6 定时运行作业
Linux系统提供了多个在预选时间运行脚本的方法：at命令和cron表。
at [-f filename] time
默认情况下，at命令会将STDIN的输入放到队列中。你可以用-f参数来指定用于读取命令（脚
本文件）的文件名。
time参数指定了Linux系统何时运行该作业。如果你指定的时间已经错过，at命令会在第二
天的那个时间运行指定的作业。
在如何指定时间这个问题上，你可以非常灵活。at命令能识别多种不同的时间格式。
 标准的小时和分钟格式，比如10:15。
 AM/PM指示符，比如10:15 PM。
 特定可命名时间，比如now、noon、midnight或者teatime（4 PM）。
除了指定运行作业的时间，也可以通过不同的日期格式指定特定的日期。
 标准日期格式，比如MMDDYY、MM/DD/YY或DD.MM.YY。
 文本日期，比如Jul 4或Dec 25，加不加年份均可。
 你也可以指定时间增量。
 当前时间+25 min
 明天10:15 PM
 10:15+7天

//作业队列 
在你使用at命令时，该作业会被提交到作业队列（job queue）。作业队列会保存通过at命令
提交的待处理的作业。针对不同优先级，存在26种不同的作业队列。作业队列通常用小写字母a~z
和大写字母A~Z来指代。
作业队列的字母排序越高，作业运行的优先级就越低（更高的nice值）。默认情况下，at的作业会被提交到a作业队列。
如果想以更高优先级运行作业，可以用-q参数指定不同的队列字母。

//作业队列中作业的输出 
当作业在Linux系统上运行时，显示器并不会关联到该作业。取而代之的是，Linux系统会将
提交该作业的用户的电子邮件地址作为STDOUT和STDERR。任何发到STDOUT或STDERR的输出都
会通过邮件系统发送给该用户。所以最好在程序中重定向STDOUT和STDERR 

如果不想在at命令中使用邮件或重定向，最好加上-M选项来屏蔽作业产生的输出信息。

atq命令可以查看系统中有哪些作业在等待
用atrm命令来删除等待中的作业。

Linux系统使用cron程序来安排要定期执行的作业。cron程序会在后台运行并检查一个特殊的
表（被称作cron时间表），以获知已安排执行的作业。

min hour dayofmonth month dayofweek command
如果想在每天的10:15运行一个命令，可以用cron时间表条目：
15 10 * * * command
在dayofmonth、month以及dayofweek字段中使用了通配符，表明cron会在每个月每天的10:15
执行该命令。要指定在每周一4:15 PM运行的命令，可以用下面的条目：
15 16 * * 1 command
可以用三字符的文本值（mon、tue、wed、thu、fri、sat、sun）或数值（0为周日，6为周六）
来指定dayofweek表项。
这里还有另外一个例子：在每个月的第一天中午12点执行命令。可以用下面的格式：
00 12 1 * * command
dayofmonth表项指定月份中的日期值（1~31）。

常用的方法是加一条使用date命令的if-then语句来检查明天的日期是不是01：
//date +%d 显示成十进制格式 
00 12 * * * if [`date +%d -d tomorrow` = 01 ] ; then ; command
它会在每天中午12点来检查是不是当月的最后一天，如果是，cron将会运行

列出已有的cron时间表，可以用-l选项。
$ crontab -l
默认情况下，用户的cron时间表文件并不存在。要为cron时间表添加条目，可以用-e选项。
在添加条目时，crontab命令会启用一个文本编辑器（参见第10章），使用已有的cron时间表作
为文件内容（或者是一个空文件，如果时间表不存在的话

如果你创建的脚本对精确的执行时间要求不高，用预配置的cron脚本目录会更方便。有4个
基本目录：hourly、daily、monthly和weekly。
$ ls /etc/cron.*ly
因此，如果脚本需要每天运行一次，只要将脚本复制到daily目录，cron就会每天执行它。

如果anacron知道某个作业错过了执行时间，它会尽快运行该作业。这意味着如果Linux系统
关机了几天，当它再次开机时，原定在关机期间运行的作业会自动运行。
这个功能常用于进行常规日志维护的脚本。如果系统在脚本应该运行的时间刚好关机，
日志文件就不会被整理，可能会变很大。通过anacron，至少可以保证系统每次启动时整理日
志文件。
anacron程序只会处理位于cron目录的程序
它用时间戳来决定作业
是否在正确的计划间隔内运行了。每个cron目录都有个时间戳文件，该文件位于/var/spool/ anacron。
$ sudo cat /var/spool/anacron/cron.monthly

anacron程序使用自己的时间表（通常位于/etc/anacrontab）来检查作业目录
period delay identifier command
period条目定义了作业多久运行一次，以天为单位。anacron程序用此条目来检查作业的时间
戳文件。delay条目会指定系统启动后anacron程序需要等待多少分钟再开始运行错过的脚本。
command条目包含了run-parts程序和一个cron脚本目录名。run-parts程序负责运行目录中传给它的
任何脚本。
注意，anacron不会运行位于/etc/cron.hourly的脚本。这是因为anacron程序不会处理执行时间
需求小于一天的脚本。
identifier条目是一种特别的非空字符串，如cron-weekly。它用于唯一标识日志消息和错误
邮件中的作业。

基本上，依照下列顺序所找到的第一个文件会被运行，其余的
文件会被忽略：
 $HOME/.bash_profile
 $HOME/.bash_login
 $HOME/.profile
因此，应该将需要在登录时运行的脚本放在上面第一个文件中

.bashrc文件通常也是通过某个bash启动文件来运行的。因为.bashrc文件会运行两次：一次是
当你登入bash shell时，另一次是当你启动一个bash shell时。如果你需要一个脚本在两个时刻都得
以运行，可以把这个脚本放进该文件中。

