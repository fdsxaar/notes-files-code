第20 章 正则表达式

在Linux中，有两种流行的正则表达式引擎：
 POSIX基础正则表达式（basic regular expression，BRE）引擎
 POSIX扩展正则表达式（extended regular expression，ERE）引擎

sed编辑器只符合了BRE引擎规范的子集

POSIX BRE引擎通常出现在依赖正则表达式进行文本过滤的编程语言中。它为常见模式提供
了高级模式符号和特殊符号，比如匹配数字、单词以及按字母排序的字符。

gawk程序用ERE引擎来处理它的正则表达式模式。

20.2 定义BRE 模式
第一条原则就是：正则表达式模式都区分大小写。这意味着它们只会匹配大小写也相符
的模式。
$ echo "This is a test" | sed -n '/this/p'

正则表达式识别的特殊字符包括：
.*[]^${}\+?|()

#正斜线也需要转义，
#诡异的是 
$echo "\fuck" | sed -n "/\\/p"    //双引号错误
$echo "\fuck" | sed -n '/\\/p'    //单引号正确
由于反斜线是特殊字符，如果要在正则表达式模式中使用它，你必须对其转义，这样就产生
了两个反斜线。
$ echo "\ is a special character" | sed -n '/\\/p'
\ is a special character
$
最终，尽管正斜线不是正则表达式的特殊字符，但如果它出现在sed编辑器或gawk程序的正
则表达式中，你就会得到一个错误。
$ echo "3 / 2" | sed -n '///p'
sed: -e expression #1, char 2: No previous regular expression
$
要使用正斜线，也需要进行转义。
$ echo "3 / 2" | sed -n '/\//p'
3 / 2

20.2.3 锚字符
1. 锁定在行首
脱字符（^）定义从数据流中文本行的行首开始的模式。
echo "Books are great" | sed -n '/^Book/p'

如果你将脱字符放到模式开头之外的其他位置，那么它就跟普通字符一样，不再是特殊字符了：
$echo "This ^ is a test" | sed -n '/s \^/p'
$echo "This ^ is a test" | sed -n '/s ^/p'
如果指定正则表达式模式时只用了脱字符，就不需要用反斜线来转义。但如果你在模式
中先指定了脱字符，随后还有其他一些文本，那么你必须在脱字符前用转义字符。

2. 锁定在行尾
特殊字符美元符（$）定义了行尾锚点

3.组合锚点
将两个锚点直接组合在一起，之间不加任何文本，这样过滤出数据流中的空白行
文档中删除空白行的有效方法。
sed  '/^$/d' data.txt

特殊字符点号用来匹配除换行符之外的任意单个字符。它必须匹配一个字符，如果在点号字
符的位置没有字符，那么模式就不成立。
sed -n '/.at/p' data6

20.2.5 字符组
可以定义用来匹配文本模式中某个位置的一组字符。如果字符组中的某个字符出现在了数据
流中，那它就匹配了该模式。
方括号来定义一个字符组;
字符组中必须有个字符来匹配相应的位置;
在不太确定某个字符的大小写时，字符组会非常有用。
可以在单个表达式中用多个字符组。
#匹配单个字符
$ echo "Yes" | sed -n '/[Yy][Ee][Ss]/p'

20.2.6 排除型字符组
寻找组中没有的字符，在字符组的开头加个脱字符。
echo "fuck" | sed -n "/fu[^y]k/p"

20.2.7 区间
用单破折线符号在字符组
中表示字符区间。只需要指定区间的第一个字符、单破折线以及区间的最后一个字符就行了。根
据Linux系统采用的字符集（参见第2章），正则表达式会包括此区间内的任意字符
可以在单个字符组指定多个不连续的区间
[0-9a-zA-Z]

20.2.8 特殊的字符组
表20-1 BRE特殊字符组
组 描 述
[[:alpha:]] 匹配任意字母字符，不管是大写还是小写
[[:alnum:]] 匹配任意字母数字字符0~9、A~Z或a~z
[[:blank:]] 匹配空格或制表符
[[:digit:]] 匹配0~9之间的数字
[[:lower:]] 匹配小写字母字符a~z
[[:print:]] 匹配任意可打印字符
[[:punct:]] 匹配标点符号
[[:space:]] 匹配任意空白字符：空格、制表符、NL、FF、VT和CR
[[:upper:]] 匹配任意大写字母字符A~Z


20.2.9 星号
在字符后面放置星号表明该字符必须在匹配模式的文本中出现0次或多次。
$ echo "fuuuuk" | sed -n "/fu*k/p"
这个模式符号广泛用于处理有常见拼写错误或在不同语言中有拼写变化的单词
$ echo "I'm getting a colour TV" | sed -n '/colou*r/p'
$ echo "baat" | sed -n '/b[ae]*t/p'
baat
$ echo "baaeeet" | sed -n '/b[ae]*t/p'
baaeeet
$ echo "baeeaeeat" | sed -n '/b[ae]*t/p'
baeeaeeat
$ echo "baakeeet" | sed -n '/b[ae]*t/p'
$
只要a和e字符以任何组合形式出现在b和t字符之间（就算完全不出现也行）

# 点号无法匹配换行符
将点号特殊字符和星号特殊字符组合起来。这个组合能够匹配任意数量
的任意字符。它通常用在数据流中两个可能相邻或不相邻的文本字符串之间。
echo "fuaeaeuuuk" | sed -n '/f.*k/p'
星号还能用在字符组上。它允许指定可能在文本中出现多次的字符组或字符区间。

20.3 扩展正则表达式
#总结
gawk程序能够识别ERE模式，但sed编辑器不能。
问号? 加号+ 花括号{} 管道符号| 圆括号()表达式分组
必须指定gawk程序的--re-interval命令行选项才能识别正则表达式间隔

本节将介绍可用在gawk程序脚本中的较常见的ERE模式符号。
20.3.1 问号
问号表明前面的字符可以出现0次或1次
echo "fuck" | gawk -n '/f[u]?ck/{print $0}'

//对于整个字符组而言 
#如果字符组中的字符出现了0次或1次，模式匹配就成立。但如果两个字符都出现了，或者其
#中一个字符出现了2次，模式匹配就不成立
echo "beat" | gawk '/b[ae]?t/{print $0}'
echo "fuck" | gawk -n '/f[uc]?k/{print $0}'
echo "beat" | gawk '/b[ae]?t/{print $0}'

20.3.2 加号
加号表明前面的字符可以出现1次或多次，但必须至少出现1次；这次如果字符组中定义的任一字符出现了，
文本就会匹配指定的模式。
echo "fuck" | gawk -n '/f[uc]+k/{print $0}'
echo "beet" | gawk '/b[ae]+t/{print $0}'

20.3.3 使用花括号
这通常称为间隔（interval）。
可以用两种格式来指定区间。
 m：正则表达式准确出现m次。
 m, n：正则表达式至少出现m次，至多n次

必须指定gawk程序的--re-interval命令行选项才能识别正则表达式间隔。
echo "fuuuuck" | gawk --re-interval '/fu{4}ck/{print $0}'
echo "fuuuuck" | gawk --re-interval '/f[uc]{1,100}ck/{print $0}'


$ echo "beeat" | gawk --re-interval '/b[ae]{1,2}t/{print $0}'
$
$ echo "baeet" | gawk --re-interval '/b[ae]{1,2}t/{print $0}'
$
$ echo "baeaet" | gawk --re-interval '/b[ae]{1,2}t/{print $0}'
$
如果字母a或e在文本模式中只出现了1~2次，则正则表达式模式匹配；否则，模式匹配失败。
20.3.4 管道符号
expr1|expr2|...
正则表达式和管道符号之间不能有空格，否则它们也会被认为是正则表达式模式的一部分。
echo "fuck fucker fonker" | gawk  '/fuck|fucker|fonker/{print $0}'

20.3.5 表达式分组
正则表达式模式也可以用圆括号进行分组。当你将正则表达式模式分组时，该组会被视为一
个标准字符；
echo "cat" | gawk '/(c|b)a(b|t)/{print $0}'
